= element HardCyt isa QCyt
\symbol HC
\color #55b
\symmetries all
local constant Unsigned cDISTANCE_BITS = 4u;
local typedef Unsigned(cDISTANCE_BITS) Distance;
local constant Unsigned cROLE_BITS = 2u;
local typedef Unsigned(cROLE_BITS) Role;
local constant Unsigned cCORPORATE_DIAMETER = 5u;
local typedef EventWindow.SiteNum SiteNum;
local constant Unsigned cCELL_TARGET_DIAMETER = 7u;
local constant Unsigned cCELL_TARGET_VOLUME = cCELL_TARGET_DIAMETER * cCELL_TARGET_DIAMETER;
local constant Unsigned cCELL_TARGET_RADIUS = cCELL_TARGET_DIAMETER / 2u;
#local typedef Unsigned(3) ParentPointer;

== Data members
u Distance mDistances[4];  // WNSE
#u ParentPointer mParent;
u Role mRole = 0;  // What level I am in the organization
u Bool mServing = false;  // Whether I'm part of an established chain of command

== Methods
getColor {
.  if (mDie) return cu.color(0xffffffu); // White for death
.  ColorUtils.ARGB base = super.getColor($selector);
.  ColorUtils.ARGB flavor = cu.color(0x5555bbu);
.  if (mRole == mRole.maxof) flavor = cu.color(0xffff00u);
.  if (mRole == mRole.maxof-1u) flavor = cu.color(0xbbbb00u);
.  if (mRole == mRole.maxof-2u) flavor = cu.color(0x999900u);
.  return modulate(base,flavor);
. }

u SoftCyt soften() {
.   SoftCyt sc;         // All defaults
.   QCyt & qc = sc;
.   mEnergy -= 2u;      // Pay energy first
.   qc = self;          // Now copy shared state
.    DebugUtils du;
.    du.print("Softening ->");
.    du.print(self);
.    du.print(sc);
.   return sc;
. }

u Unsigned getWidthEstimate() {
.   return (1u + mDistances[0] + mDistances[3]); // us+W+E
. }

u Unsigned getHeightEstimate() {
.   return (1u + mDistances[1] + mDistances[2]); // us+N+S
. }

u Unsigned getVolumeEstimate() {
.   return getWidthEstimate() * getHeightEstimate();
. }

u C2D getPositionEstimate() {
.   C2D pos;
.   pos.set((Int) mDistances[3] - mDistances[0],(Int) mDistances[2] - mDistances[1]);
.   return pos;
. }


u Bool shouldImport(Atom atom) {
.   return true
.      && atom is Res
.      && (mEnergy < mEnergy.maxof  // ..and either I can use it, or the cell
.       || getVolumeEstimate() < cCELL_TARGET_VOLUME  // could stand to be bigger
.         )
.   ;
. }

u Bool shouldExport(Atom atom) {
.   return
.       atom is DReg  // We don't want DReg in here AT ALL
.    || (atom is Res  // But we like Res.  Only eject it if
.     && !mServing    // I'm not in the administration, and
.     && mEnergy == mEnergy.maxof   // I don't need it, and the cell
.     && getVolumeEstimate() > cCELL_TARGET_VOLUME  // doesn't need to be bigger
.       )
.   ;
. }

u Unsigned getNgbDirIndex(C2D ngb) {
.    EventWindow ew;
.    SiteNum sn = ew.getSiteNumber(ngb);
.    return sn-1u;
. }

u Unsigned getWestIndex() {
.    C2D c(-1,0);
.    return getNgbDirIndex(c);
. }

u Unsigned getNorthIndex() {
.    C2D c(0,-1);
.    return getNgbDirIndex(c);
. }


== Rules (Fatal conditions)
given @ isa HardCyt :
.  !$self.mDie &&                                 // Not already dying, and
.  ($self.getWidthEstimate() >= Distance.maxof || // somehow hopelessly
.   $self.getHeightEstimate() >= Distance.maxof)  // oversized
change @ isa QCyt { $self.mDie = true; }

  @ -> @

== Postrules (Leader movement)
given @ isa HardCyt : $self.mRole == $self.mRole.maxof
given S isa Swapon
given h isa HardCyt

 hS@ -> @_h

== Postrules (Update distance estimates)

given @ isa HardCyt
given q isa QMembrane
given h isa HardCyt
let x = q|h
check @ {
.   HardCyt & h = (HardCyt&) ew[0];
.   Unsigned westIdx = h.getWestIndex();
.   if ($q.$nvotes > 0u) h.mDistances[westIdx] = 0u; // Believen my lyin' eyes
.   else if ($h.$nvotes > 0u) {                      // Believen whachu tell me
.     HardCyt & h2 = (HardCyt&) ew[$h.$winsn];
.
.     // Increment in axis direction
.     h.mDistances[westIdx] = (Distance) (h2.mDistances[westIdx]+1u);
.
.     // Max in orthogonal direction
.     Unsigned northIdx = h.getNorthIndex();
.     if (h2.mDistances[northIdx] > h.mDistances[northIdx])
.       h.mDistances[northIdx] = h2.mDistances[northIdx];
.   }
.   return false;
. }

 x.@ -> ...


== Postrules (If not me then who)

given @ isa HardCyt :
.  $self.mRole != Role.maxof &&                        // Not already the leader, not
.  !$self.mServing &&                                  // in the chain of command leader, but
.  $self.getWidthEstimate() >= cCORPORATE_DIAMETER &&  // the world is
.  $self.getHeightEstimate() >= cCORPORATE_DIAMETER && // big enough and we seem
.  $self.getPositionEstimate().isOrigin()              // to be dead center of it

change @ isa HardCyt {
.  ++$self.mRole;                    // I'm more important here than I thought
.  if ($self.mRole == Role.maxof)    // In fact, I say I'm now
.    $self.mServing = true;          // serving as the leader of us all
. }

given h isa HardCyt :
.  $self.mRole != Role.maxof &&
.  !$self.mServing

  h.h.h      .....
  .....      .....
  h.@.h  ->  ..@..
  .....      .....
  h.h.h      .....

== Postrules (C-suite management)

scratch 0 = 0       // To max over ngb roles

given @ isa HardCyt :
.  $self.mRole != Role.maxof                           // Not already the leader, but

vote h isa HardCyt {
.  if (!$self.mServing) return 0u;
.  if ($self.mRole > $0) $0 = $self.mRole;  // New front-runner
.  return 1u;
. }

check @ {
.  HardCyt & hc = (HardCyt&) ew[0];
.  if ($h.$nvotes > 0u) {
.    hc.mRole = (Role) ($0 - 1);  // Saturating at 0u below
.    hc.mServing = (hc.mRole > 0u);
.  } else {                // If nobody to serve
.    hc.mRole = 0u;        // then I have no role
.    hc.mServing = false;  // and I'm not serving
.  }
.  return false;  // Drive-by update
. }

    h          .
    .          .
  h.@.h  ->  ..@..
    .          .
    h          .


== Postrules (Growth)

given @ isa HardCyt : $self.mEnergy == $self.mEnergy.maxof

vote e isa Empty
vote r isa Res

change @ {
.   if ($e.$nvotes > 0u && $r.$nvotes > 0u) {
.     HardCyt & hc = (HardCyt&) ew[0];
.     hc.mEnergy = 0u;       // Reproduction is tiring to all
.     HardCyt copy = hc;
.     --copy.mRole = 0u;     // Copy has to find its own job
.     ew[$e.$winsn] = copy; 
.     ew[$r.$winsn] = Empty.instanceof;
.   }
. }

     e        .
    rrr      ...
   er@re -> ..@..
    rrr      ...
     e        .

== Postrules (Maintenance with prejudice)

given @ isa HardCyt
vote w isa HardCyt
vote h isa HardCyt
change @ {
.   if ($w.$nvotes > 0u &&  // If an H is misaligned with us
.       $h.$nvotes > 2u)    // And we have significant support
.     ew[$w.$winsn] = SoftCyt.instanceof;// The weirdo decays
. }

     h        .
    www      ...
   hw@wh -> ..@..
    www      ...
     h        .

== Postrules (Spike and corner melting)

given @ isa HardCyt :
.    $self.mServing == false
. && $self.getVolumeEstimate() > cCELL_TARGET_VOLUME


given q isa QMembrane
check _ : random.oneIn(5)

change @ isa HardCyt {
. ew[$_.$winsn] = $self.soften();
. ew[0] = Empty.instanceof;
.}


  qqq    ...
  q@_ -> .@.
  qqq    ...


  q__    ...
  q@_ -> .@.
  qqq    ...


== Postrules (Hold)

     @  -> @      # Else hold
