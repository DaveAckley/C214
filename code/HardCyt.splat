= element HardCyt isa QCyt
\symbol HC
\color #75b
\symmetries all
local constant Unsigned cDISTANCE_BITS = 4u;
local typedef Unsigned(cDISTANCE_BITS) Distance;
local constant Unsigned cROLE_BITS = 4u;
local typedef Unsigned(cROLE_BITS) Role;
local constant Unsigned cCORPORATE_RADIUS = 4u;
local constant Unsigned cCORPORATE_DIAMETER = 2u * cCORPORATE_RADIUS;
local typedef EventWindow.SiteNum SiteNum;
local constant Unsigned cCELL_TARGET_DIAMETER = 7u;
local constant Unsigned cCELL_TARGET_VOLUME = cCELL_TARGET_DIAMETER * cCELL_TARGET_DIAMETER;
local constant Unsigned cCELL_TARGET_RADIUS = cCELL_TARGET_DIAMETER / 2u;

== Data members
u Distance mDistances[4];  // WNSE
u Role mRole = Role.maxof;  // What level I am in the organization (if mServing)
u Bool mServing = false;  // Whether I'm part of an established chain of command

== Methods
getColor {
.  if (mDie) return cu.color(0xffffffu); // White for death
.  ColorUtils.ARGB base = super.getColor($selector);
.  ColorUtils.ARGB flavor = cu.color(0x7755bbu);
.  if (mServing) {
.    if (mRole == mRole.maxof)         flavor = cu.color(0xffff00u);
.    else if (mRole == mRole.maxof-1u) flavor = cu.color(0xbbbb00u);
.    else if (mRole == mRole.maxof-2u) flavor = cu.color(0x999900u);
.  }
.  return modulate(base,flavor);
. }

u SoftCyt soften() {
.   SoftCyt sc;         // All defaults
.   QCyt & qc = sc;
.   mEnergy -= 2u;      // Pay energy first
.   qc = self;          // Now copy shared state
.//    DebugUtils du;
.//    du.print("Softening ->");
.//    du.print(self);
.//    du.print(sc);
.   return sc;
. }

u Unsigned getWidthEstimate() {
.   return (1u + mDistances[0] + mDistances[3]); // us+W+E
. }

u Unsigned getHeightEstimate() {
.   return (1u + mDistances[1] + mDistances[2]); // us+N+S
. }

u Unsigned getVolumeEstimate() {
.   return getWidthEstimate() * getHeightEstimate();
. }

u C2D getPositionEstimate() {
.   C2D pos;
.   pos.set((Int) mDistances[3] - mDistances[0],(Int) mDistances[2] - mDistances[1]);
.   return pos;
. }

u Unsigned getOutDistanceEstimate() {
.   if (!mServing) return 0u;             // initial condition
.   return mRole.maxof - mRole;           // Leader is 0 and on up
. }

u Bool inFreezingRange() {
.   return getOutDistanceEstimate() <= cCORPORATE_RADIUS;
. }

u Bool shouldImport(Atom atom) {
.   return true
.      && atom is Res
.      && (mEnergy < mEnergy.maxof  // ..and either I can use it, or the cell
.       || getVolumeEstimate() <= 3u*cCELL_TARGET_VOLUME/2u  // isn't already too huge
.         )
.   ;
. }

u Bool shouldExport(Atom atom) {
.   return
.       atom is DReg  // We don't want DReg in here AT ALL
.    || (atom is Res  // But we like Res.  Only eject it if
.     && mEnergy == mEnergy.maxof   // I don't need it, and the cell really
.     && getVolumeEstimate() > 3u*cCELL_TARGET_VOLUME/2u  // doesn't need to be bigger
.       )
.   ;
. }

== Rules (Fatal conditions)
given @ isa HardCyt :
.  !$self.mDie &&                                 // Not already dying, and
.  ($self.getWidthEstimate() >= Distance.maxof || // somehow hopelessly
.   $self.getHeightEstimate() >= Distance.maxof)  // oversized
change @ isa QCyt { $self.mDie = true; }

  @ -> @

== Postrules (Leader movement)
given @ isa HardCyt : $self.mRole == Role.maxof
given S isa Swapon
given h isa HardCyt

 hS@ -> @_h

== Postrules (Leader wander)

given @ isa HardCyt {
.  if ($self.mRole != Role.maxof) return false;
.  if ($self.getWestIndex() != 0u) return false; // Heading east for test!
.  if (!random.oneIn(100)) return false;
.  for (Int i = 0; i < 4; ++i)
.    if ($self.mDistances[i] < 2u) return false;
.  return true;
. }

given h isa HardCyt
change S isa Swapon

 @_h -> .S.

== Postrules (Update distance estimates)

given @ isa HardCyt
given q isa QMembrane
given h isa HardCyt
let x = q|h
check @ {
.   HardCyt & h = (HardCyt&) ew[0];
.   Unsigned westIdx = h.getWestIndex();
.   if ($q.$nvotes > 0u) h.mDistances[westIdx] = 0u; // Believen my lyin' eyes
.   else if ($h.$nvotes > 0u) {                      // Believen whachu tell me
.     HardCyt & h2 = (HardCyt&) ew[$h.$winsn];
.
.     // Increment in axis direction
.     h.mDistances[westIdx] = (Distance) (h2.mDistances[westIdx]+1u);
.
.     // Max in orthogonal direction
.     Unsigned northIdx = h.getNorthIndex();
.     if (h2.mDistances[northIdx] > h.mDistances[northIdx])
.       h.mDistances[northIdx] = h2.mDistances[northIdx];
.   }
.   return false;
. }

 x.@ -> ...


== Postrules (If not me then who)

given @ isa HardCyt :
.  !$self.mServing &&                                  // If not serving, but
.  $self.getWidthEstimate() >= cCORPORATE_DIAMETER &&  // the world is
.  $self.getHeightEstimate() >= cCORPORATE_DIAMETER && // big enough and we seem
.  $self.getPositionEstimate().isOrigin()              // to be dead center of it

change @ isa HardCyt {
.  $self.mRole += 2u;                // I'm more important here than I thought
.  if ($self.mRole == Role.maxof)    // In fact, I say I'm now
.    $self.mServing = true;          // serving as the leader of us all
. }

given h isa HardCyt : !$self.mServing  // If nobody around me is serving

  h.h.h      .....
  .....      .....
  h.@.h  ->  ..@..
  .....      .....
  h.h.h      .....

== Postrules (C-suite management)

scratch 0 = 0       // To max over ngb roles

given @ isa HardCyt : !$self.mServing || $self.mRole != Role.maxof   // Not serving, or not leader

vote h isa HardCyt {
.  if (!$self.mServing) return 0u;
.  if ($self.mRole > $0) $0 = $self.mRole;  // New front-runner
.  return 1u;
. }

check @ {
.  HardCyt & hc = (HardCyt&) ew[0];
.  hc.mRole = (Role) ($0 - 1);     // Saturating at 0u below
.  hc.mServing = (hc.mRole > 0u);  // No role, not serving
.  return false;  // Drive-by update
. }

    h          .
    .          .
  h.@.h  ->  ..@..
    .          .
    h          .


== Postrules (Growth)

given @ isa HardCyt :
.    $self.mEnergy == $self.mEnergy.maxof
. && $self.inFreezingRange()

vote e isa Empty
vote r isa Res

change @ {
.   if ($e.$nvotes > 0u && $r.$nvotes > 0u) {
.     HardCyt & hc = (HardCyt&) ew[0];
.     hc.mEnergy = 0u;       // Reproduction is tiring to all
.     HardCyt copy = hc;
.     --copy.mRole;          // Assume copy is lower rank than parent
.     ew[$e.$winsn] = copy; 
.     ew[$r.$winsn] = Empty.instanceof;
.   }
. }

     e        .
    rrr      ...
   er@re -> ..@..
    rrr      ...
     e        .

== Postrules (Maintenance with prejudice)

given @ isa HardCyt
vote w isa HardCyt
vote h isa HardCyt
change @ {
.   if ($w.$nvotes > 0u &&  // If an H is misaligned with us
.       $h.$nvotes > 2u)    // And we have significant support
.     ew[$w.$winsn] = SoftCyt.instanceof;// The weirdo decays
. }

     h        .
    www      ...
   hw@wh -> ..@..
    www      ...
     h        .

== Postrules (Spike and corner melting)

given @ isa HardCyt :
.    $self.mRole < Role.maxof/2u  // Off in the distance to melt
. && $self.getVolumeEstimate() > cCELL_TARGET_VOLUME


given q isa QMembrane
check _ : random.oneIn(3)

change @ isa HardCyt {
. ew[$_.$winsn] = $self.soften();
. ew[0] = Empty.instanceof;
.}


  qqq    ...
  q@_ -> .@.
  qqq    ...


  q__    ...
  q@_ -> .@.
  qqq    ...


== Postrules (Hold)

     @  -> @      # Else hold
