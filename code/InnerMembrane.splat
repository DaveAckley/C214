= element InnerMembrane isa QMembrane
\symbol IM
\color #6789ab
\symmetries all
local constant Unsigned cGRADIENT_BITS = 6;
local typedef Unsigned(cGRADIENT_BITS) GradVal;
local constant Unsigned cLOWPASS_BITS = 4;
local typedef Unsigned(cLOWPASS_BITS) LowPass;

== Data members
u GradVal mGradVal = GradVal.maxof;
u LowPass mLocalMax; // LowPass.maxof if my gradient exceeds all my neighbors

== Methods
getColor {
. if (mGradVal == GradVal.maxof) return super.getColor($selector);
. if (mGradVal == GradVal.minof) return cu.color(0xffff00u);
. if (mLocalMax == LowPass.maxof) return cu.color(0xccccccu);
. Unsigned incr = 2u*(GradVal.maxof-mGradVal);
. ARGB ret = cu.color((ColorUtils.Byte) (0x70+incr),
.                    (ColorUtils.Byte) (0x89/2),
.                    (ColorUtils.Byte) (0xab/2));
. return ret;
.}

# == Rules (Highlander)
# given @ isa InnerMembrane : $self.mGradVal == GradVal.minof
# vote i isa InnerMembrane   {
# .  if ($self.mGradVal == GradVal.minof) {
# .    ++$self.mGradVal;
# .  }
# .  return 0u;
# .}
     
#   i      .  
#  i@i -> ...
#   i      .

== Rules (settle)
scratch 0 = GradVal.maxof + 1
scratch 1 = -1
given @ isa InnerMembrane : $self.mGradVal != GradVal.minof
vote i isa InnerMembrane {
.  if ($self.mGradVal < $0) $0 = $self.mGradVal;
.  if ($self.mGradVal > $1) $1 = $self.mGradVal;
.  return 1u;
. }
check @ {
.  InnerMembrane & im = (InnerMembrane &) ew[0]; 
.  Int maxmin = $0 + 1;
.  if (im.mGradVal >= $1) ++im.mLocalMax;
.  else im.mLocalMax = LowPass.minof;
.  if (maxmin < im.mGradVal)
.    im.mGradVal = (GradVal) maxmin;
.  else
.    ++im.mGradVal;
.  return false;
. }

    i      .
   i@i -> ...
    i      .

