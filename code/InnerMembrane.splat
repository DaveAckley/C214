= element InnerMembrane isa QMembrane
\symbol IM
\color #6789ab
\symmetries all
local constant Unsigned cREFRACTORY_BITS = 3;
local typedef Unsigned(cREFRACTORY_BITS) BurnState;
local constant BurnState cBURNING = BurnState.minof;
local constant BurnState cBURNABLE = cBURNING+1u;
local constant BurnState cBURNT = BurnState.maxof;
local constant Unsigned cAUTO_SPARK_ODDS = 500u;

== Data members
u BurnState mBurnState = cBURNT;

== Methods
getColor {
. if (mBurnState == cBURNABLE) return cu.color(0x6789abu);
. if (mBurnState == cBURNING) return cu.color(0xffff00u);
. Unsigned incr = 10u*(BurnState.maxof-mBurnState);
. ARGB ret = cu.color((ColorUtils.Byte) (0x80+incr),
.                    (ColorUtils.Byte) (0x89/2),
.                    (ColorUtils.Byte) (0xab/2));
. return ret;
.}

== Rules (asymmetric spark)

given O isa OuterMembrane
given N : ! ($curatom is QMembrane)  // Neither inner nor outer

given @ isa InnerMembrane : $self.mBurnState == cBURNABLE
given I isa InnerMembrane : $self.mBurnState == cBURNABLE

check @ : random.oneIn(cAUTO_SPARK_ODDS)

change @ isa InnerMembrane { $self.mBurnState = cBURNING; }
change I isa InnerMembrane { $self.mBurnState = cBURNT; }

 OOO     ...
 @II  -> @II
 NNN     ...

== Rules (regrow)

given @ isa InnerMembrane : $self.mBurnState > cBURNABLE
check @ { InnerMembrane & im = (InnerMembrane &) ew[0]; --im.mBurnState; return false; }

   @ -> .

== Rules (burn)

given @ isa InnerMembrane : $self.mBurnState == cBURNING
vote i isa InnerMembrane  : $self.mBurnState == cBURNABLE
check @ {
.  InnerMembrane & im = (InnerMembrane &) ew[0]; im.mBurnState = cBURNT;
.  if ($i.$nvotes > 0u) {
.    InnerMembrane & im2 = (InnerMembrane &) ew[$i.$winsn];
.    im2.mBurnState = cBURNING;
.  }
.  return false;
. }

    i      .
   i@i -> ...
    i      .

