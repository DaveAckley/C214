{99}  -*- text -*-
[0:

Wed Feb 20 03:00:03 2019 OK time for an ALIFE19 paper.  The goal is
some kind of more structured reproduction than we saw in the 2018
'cancer cells' demo.  The plan, such as it is, is

(1) to build a quasicrystal-like molecule, something like the
    generalized crystals from 2014 (like
    https://www.youtube.com/watch?v=C6h3gvaKE7E ) and then

(2) get them to move with something like the asymmetric diffusion from
    2011 ( https://youtu.be/ykeNAmJ8pa4 ), and

(3) put them all in some C211-like bag (like 2018), for some good
    reason -- perhaps using the membrne to sense the environment and
    determine when conditions are plausible

(4) to perform a reproduction by having each guy in the crystal twin
    and then pull apart.

[1:

Wed Feb 20 03:26:34 2019 Well but when you write it all down like that
it seems like a lot of work for three weeks to a finished paper.

[2:

Wed Feb 20 03:27:10 2019 So let's get some quick breakdown TODO to get
us started.

[3: Wed Feb 20 06:12:43 2019
DONE Quasicrystal.splat  :3] - Build a telomere-controlled quasicrystal in SPLAT, requiring

[4: DONE  :4] - Get SPLAT set up and working in this directory

Foggit let's just do that right now and then come back.  (Although I'm
tempted to say: That builds from Res. [5: Wed Feb 20 06:13:12 2019
DONE ResQX.splat :5])

:2]

:1]

:0]
[6:

Wed Feb 20 06:13:39 2019 So we currently are going for a distance 3
spacing but that really does seem pretty loose -- and folks get lost
pretty easily at the edges.  We're going to put in a C211 membrane to
help reduce edge losses, but thinking we should try a period 2
membrane.. [8:

Wed Feb 20 06:36:00 2019 And I want to go Res-controlled instead of
telomere-controlled.  But do we have any evidence C211 can really
withstand DReg?

:8]

:6]
[7:

Wed Feb 20 06:35:13 2019 Also fixed some bad error reporting in
splattr..  Nice to be able to do that a little..

:7]
[9:

Thu Feb 21 10:31:51 2019 OK, now into ../code/201902211027-c213/ and
working on the membrane more.  Sort have IM burning in a pretty
rickety ring oscillator, and want something more robust.  Also have
a general "controllable membrane permeability" feature running at a
cost of 16 bits.[10:

Thu Feb 21 10:35:47 2019 But let's make the permeability less general
and cut it down to say four bits with a hardcoded permeability table.

:10]

Planning on ditching telomere controlled guts growth in favor of Res
contolled, using controlled permeability to turn on and off Res uptake
to modulate growth.

:9][11:

Thu Feb 21 10:38:04 2019 And what about making a 1D guts?  We do need
to get back to programmability eventually.

TODO:

 - Permeability table

 - mExport as well?

 - Push DReg away harder

 - Go for a 'standing gradient' on IM instead of a ring burn.

:11]
[12:

Thu Feb 21 11:02:28 2019 Hmm, on the permeability table, what if we
didn't store anything, but instead looked for some content on the fly
to ask if _this_ piece of membrane is open to _this_ possible import
_right now_?  Push the decision (and any associated storage cost) back
onto the content rather than pulling it forward to the membrane 'for
efficiency'.  But could we make a rule that would ever fire?

:12]
[13:

Fri Feb 22 03:37:24 2019 So we like the just-ask-QContent-on-the-fly
approach to the import decision.  It's still stigmergic, at least from
the membrane's point of view, but it's much more flexible than mere
geometry.

So, now we've moved on to ALIFE19/code/201902220336-grad/, and our
goal is to ditch the ring burn oscillator for a standing gradient
stabilizer. [14:

Sat Feb 23 07:13:52 2019 OK we made a gradient stabilizer, buuuut
given how much the membrane moves around, it's not all that stable
either.  In particular, it's to keep a single 'gradient anchor' point
alive as the membrane grows and shrinks.  You can get a relatively
durable but potentially unbounded _group_ of anchors, or you can have
a single anchor that gets killed pretty often..

[15:

Sat Feb 23 07:16:01 2019 We're thinking screw the membrane stuff for
now, and the next stop should be getting the interior goo to have a
hybrid solid/liquid' nature.  Content in 'solid' mode crystallizes
into a (bounded) side 2 square, while content in 'liquid' mode moves
in the odd phase empty spaces among the solid.

:15]

:14]

:13]
[16:

Sat Feb 23 11:44:32 2019 Moving these notes to ../code/C213/notes/ to
get into the noo! sekrit! mimburrs ownlee! repo.

:16]
[17:

Sat Feb 23 11:57:30 2019 OK.  So let's do solid crystallization first
and alone.

TODO:

[19: DONE Sat Feb 23 14:22:20 2019   :19] - Restart QX2 as QCyt.splat, make it a quark

[21: DONE, though only H does anything  :21] - Have HardCyt and SoftCyt as subclasses

[20: DONE  :20] - Make HardCyt grow from Res, forming a side 2 square lattice

 - Define HardCyt 'support' as the number of aligned HC neighbors.
   Have HC decay back to Res if it sees IM..[18: Sat Feb 23 12:09:11
   2019 Later, later.  Just get started now  :18]

:17][22:

Sat Feb 23 14:22:58 2019 OK, so we're building a H matrix now.

TODO:

[23: Sat Feb 23 16:48:54 2019
DONE for HardCyt, but WNSE == sitenum-1 :23] - Make NSEW distance estimators, measured in terms of H matrix
   cells.

[24: Sat Feb 23 16:48:59 2019
DONE :24] - Have H settle towards size/position info in terms of distance
   estimators

[25: Sun Feb 24 03:50:12 2019
DONE :25] - Stop importing Res once estimators exceed some threshold

:22]
[26:

Sun Feb 24 03:50:22 2019 OK so the distance estimators are workingish,
although (surprise) using them to limit cell growth has some
unexpected consequences.  Since they measure distance-from-IM, if we
can neck down the membrane in the middle, the cell can grow
in sort of a figure-8 shape and basically double its volume..

Just like if it was reproducing...

:26][27:

Sun Feb 24 03:54:43 2019 So more

TODO:

[30: Sun Feb 24 05:57:57 2019
DONE :30] - Extend distance estimator to do not just 1+nghb in the 'axis'
   direction but also max(nghb) in the 'orthogonal' direction.
   Worried that will lead to 'ghost distances' but we need to try
   coupling across rows/columns somehow.

[32: Sun Feb 24 08:12:05 2019 Can even export DReg and import Res in one event!
DONE :32] - Export DReg.  Despite everything it managed to get into the cells
   on the evening/night long-run test.

 - Review/debug QMembrane rules.  We observed crosses and chipped caps
   in the long run.  We're not sure if we broke something that used to
   prevent/fix them, or if (we suspect) DReg is implicated in their
   formation, but either way nothing seemed to degrade or repair them.

            IO                   OO
    Cross:  OI    Chipped cap:   OIO

    We'd like chipped caps to fill:  oO_ -> ..O
    with o isa OM and O isa OM.      oIO    ...

                                      ___     ...
    At least, if there's nothing     oO__ -> ..O.
    confounding, perhaps like:       oIO_    ....

    Really not clear what to do about crosses but let's take another
    look.


 - Also saw stable edge-of-universe stubs we'd like to get rid of:

               ddd
    Edge stub: OIO   # d

 - (Probably,) Ditch HardCyt & SoftCyt as types in favor of just QCyt
   with a Bool mIsHard.  We're going to want to melt and freeze QCyt
   without losing all their state.

:27]
[28:

Sun Feb 24 04:53:42 2019 So we had restricted ourselves to
'\symmetries rotations' to keep our sanity, but combining that with
our getWestIndex and getNorthIndex concepts actually meant our 'max in
the orthogonal direction' implementation missed cases where a flip is
required to make 'north' be counter-clockwise to west.

So we just finishing rebuilding with '\symmetries all' and we're
predicting it will work better.[29:

Sun Feb 24 05:03:46 2019 Playing with that (it's working as we
expected) and just noticed that two away from a HardCyt it might be an
OM, and we better accept that as a basis for 0 distance to membrane!

:29]

:28]
[31:

Sun Feb 24 05:58:12 2019 So, the 1+axis, max(ortho) concept seems to
work pretty well and with some interesting properties.

 - Yes, there can be conflicts between trusting your neighbors
   estimates vs your own observations.  With one symmetry you may see,
   say membrane to the west, and so set your west distance, while with
   another symmetry you end up maxing with your north neighbor's west
   and get a non-zero score.

 - And those conflicts absolutely do cause instabilities in distance
   estimates, whenever a given HC is on a row or column that is not,
   in fact, the max width or height.

 - But we do _not_ see 'ghost' or zombie distances persisting
   indefinitely, so long as the main connectivity of the grid is
   intact.  To the contrary estimates quite quickly to only vary
   between plausible values given the current membrane shape.

 - (Now, if a DReg gets in and starts punching holes, that can
   eliminate some estimate propagation channels and leave bad
   estimates hanging in some cells.  But we're talking dementia by
   then in any case.)

 - And for the folk, if any, that are on a max width row and a max
   height column, their distance estimates are rock solid -- and such
   folk tend to be toward the middle of the cell, and thus plausible
   candidates for elevating to some more privileged status.

:31]
[33:

Sun Feb 24 09:48:01 2019 OK, so, doing a longer run we still see DReg
managing to raise havoc, sufficiently to disrupt the membrane an let
the cyt out which then plasters the universe (along with rogue
membrane biofilms).

So it's time to implement the ripcord for these guys, giving them a
collective identity tag and the ability to trigger apoptosis if things
go too far wrong.  We're going to have membrane just vanish while Cyt
will decay back to Res even though those are pretty inconsistent
stories relative to conservation of 'matter'.  (But, we're going to
say that such 'conservation laws' are design choices, not givens, in a
hosted physics.)

(We also still need to fix at least the chipped caps, because they're
still happening and they seem fixable.)

:33]
[34:

Sun Feb 24 09:56:27 2019 Buut what if we _don't_ have an identity tag?
What if we go on spatial grounds?  Triggered Cyt destroys all the Cyt
it can see; if that stretches into (what had been) another cell well
too bad for that other cell -- it shouldn't have gotten so close.

We'll need to deal with membrane decay separately, but we can think of
conditions for Cyt to punch out:

 (1) Cyt immediately adjacent to OM

 (2) Any Cyt mDistances reaches Distance.maxof

[35:

Sun Feb 24 10:00:52 2019 Let's see how far we can get on clean dying
without QID.splat..
[36:

Sun Feb 24 10:02:21 2019 Well, for that, some

TODO:

[37: Sun Feb 24 10:53:35 2019
DONE :37] - Rip the vestiges of telomere out of QCyt

[38: Sun Feb 24 10:53:40 2019
DONE :38] - Add a QCyt.mDie Bool propagating at max velocity

[39: Sun Feb 24 10:53:55 2019
DONE :39] - Get cases :34: 1-2 going

:36]
:35]

:34]
[40:

Sun Feb 24 10:54:08 2019 OK, so now we need QMembrane death, because
on oversize death we have residual Res that keeps the membrane from
collapsing all the way.

..but wait, we don't have enough residual Res, our HardCyt is not
decaying properly; why not?

:40]
[41:

Mon Feb 25 03:51:23 2019 OK so we have both HardCyt and QMembrane
decaying in reasonably plausible ways.  Still need to deal with
chipped caps; let's go for that.[42:

Mon Feb 25 03:53:35 2019 OK, so, why doesn't 'Put your cap on' already
deal with this?  In a 'given @ isa InnerMembrane' ruleset, we have
this:

 _____     .....
 __oo_     .o...
  o@o  ->   ...     # Put your cap on

Ah I guess it's because of the _ at LHS (4,1)?

..Wait, I guess the issue really isn't as specific as a chipped cap like

  _oo
  o@o

it's more like a 'dinged corner'

  _o     oo
  o@ ->  o@

except isn't that an awful small pattern to deploy comfortably?
How could that rule really be safe?

        oo.oo
  _oo   oo_oi
  oio   iioii
  oi     ioi

[43:

Mon Feb 25 04:09:31 2019 Well, trying it

  _o     o.
  o@ ->  ..

Does that mean we want to try

  _i     i.
  i@ ->  ..

in the OM stabilization section?
[44:

Mon Feb 25 04:11:02 2019 Well, trying both.. But They Can't Be Right
They Are Too General![45:

Mon Feb 25 04:44:31 2019 Well, they might be Too General but so far
they seem to be fitting in with no ill effects..  Hard to believe we
didn't have them before.  Perhaps they used to be covered by something
we changed recently.

:45]

:44]

:43]
:42]

:41]
[46:

Mon Feb 25 08:54:16 2019 OK well I guess we can claim clean dying at
this point.  We'd like to defend against DReg a little better than we
are so far -- cells seem to be dying within a few or several hours of
runtime -- but we'll revisit that later.  Thinking about a OM-mediated
fringe of external sensors/protectors that might push out the
controlled radius.

:46][47:

Mon Feb 25 09:17:33 2019 So.  SoftCyt?  How do we go at it.  I confess
I'd rather keep HC and SC as separate types[48:

Mon Feb 25 10:02:14 2019 OK let's keep them separate.  How do we
transfer base class QCyt state from an instance of one to a newly
created instance of the other.  What's our situation on constructors
in ulam these days?[49: Tue Feb 26 15:04:06 2019 Done using Self(..)?

Ooh, the uAARM (ulam Appendix A Reference Manual) says I can put
arguments after an instanceof operator.  That should give me a base
class transfer route, yes no yes?

[50:

Tue Feb 26 15:10:07 2019 Could we also offer $Self as a SPLAT
mechanism to provide the 'top-level' Self to all rule sets?  It would
expand to the actual class name, rather than to (ulam-level) 'Self',
so it would get around the 'rule sets are different classes' issue.

:50]

:49]

:48]

:47]
[51:

Wed Feb 27 05:55:09 2019 Finally got a full-on sleep.  So to transfer
state HardCyt<->SoftCyt, can't we just do broadside parallel
assignment of the base class type?

  Base A, data member a1, a2
  Sub B isa A, data member b1
  Sub C isa A, data member c1

  B b; b.a1 = 9; b.a2 = 10; b.b1 = 11;
  C c; c.c1 = 11; // c.a1 == 0; c.a2 == 0;
  ((A&) c) = (A&) b;
  // now c.a1 == 9; c.a2 == 10; c.c1 == 11; right?

[52:

Wed Feb 27 06:06:52 2019 Well it's saying

  B initFrom(A& suba) {
    B b;
    ((A&) b) = suba;
      ^
./Base.ulam:9:7: ERROR: Explicit Reference casts (Type&) are valid for reference variable initialization (including function call arguments); not in this context.

[53:

Wed Feb 27 06:26:59 2019 Buuut this works..

  Unsigned(4) c1 = 9;
  B initFrom(Base& base) {
    B b;
    Base& r = (Base&) b;
    r = base;
    return b;
  }

so yes, we can do parallel assignment to all the base class state via
a reference-to-base

:53]

:52]

:51]
[54:

Wed Feb 27 06:40:03 2019 OK so we have 'SoftCyt soften() {..}' in
HardCyt and 'HardCyt harden() {..}' in SoftCyt, as yet untested but
plausible.  We need some QCyt state to be passed around and I'm
thinking let's toss together some little tag-value thing and have a
few of those at QCyt level.  Hard and soft might have other tags of
their own but we need to strike at a cell-wide associative pool of
knowledge real soon now, so...

8 bit tag-val?  3 tag + 5 val?  Parametrize it of course but..  Well
let's just start QTag?  Where's the value?  QTuple?  That's any
arity.  QAttr?  QProperty?

Well, what operations do we want our collective pool of t-vs to have?
Read and write?  That's pretty high level.  How about 'amplify' and
'attenuate'.  Then search.

We'd like to store a not-huge set of tag-values robustly in a
distributed, shifting pool of tag-value 'slots', and get nice
properties from the collection like:

 - Blocking reads: Can post a request for the value of a tag and then
   'suspend the thread' until that comes back.

So we're building a threaded machine on top of these TVs?

Perhaps it's time to actually go programmable and say these TVs can
read other TVs and request and control stuff?  Is there a
minimal-minimal way to think about that to get started?  After all we
don't even have cell mobility actually implemented yet.

 - Votes and quorum calls.  Make a collective decision based on how
   much support there is for something.

[55:

Wed Feb 27 07:08:54 2019 I think we need to NOT go full-on tag value
in the sense of expecting tag semantics to be immutable across the
entire collective.  We WANT to continue to use spatial locality to
resolve aliased/ambiguous tag meanings locally.

For example, suppose we used UMod tags to create a 1D sequence of
TVs within the HCs.  Anybody in the event window can have the next tag
in the sequence, but the sequence itself can stretch beyond the
event window and the tags (of course) repeat with the period of the
UMod.

So like if we put just two TVs per HC, then we could see up to 10 TVs
in an event window, so a UMod(4) tag would have slack beyond..
[56:

Wed Feb 27 07:25:21 2019 Simplify.  How about just a linear chain of
HCs, with a next and prev ptr based on direction?  Perhaps SCs could
chain based on tag identity, and that way we could freeze and melt a
1D QCyt sequence by mapping back and forth between location-based (HC
positions) and content-based (SC tags) chaining.  We'd also need
HC<->SC interface mechanisms at the melting and freezing sequence
ends, that would have one location-based pointer and one tag-based
pointer.

SC would have to not stray beyond the ..if anybody ..

So we're reinventing bonds here, step by step.  Not that reinvention
is a bad thing, oh no no.  But we should be aware of the bond
attractor as we consider our moves here.

[57:

Wed Feb 27 07:35:19 2019 So we can build a 1D HC chain using history.
The seed creates a "5'" HC end (though we won't call it that) and
subsequent HC creations (always performed by an existing HC) add on at
the "3'" end.  But, just like in the 2D printer, that creates a tree,
not a chain, unless we limit the 3' creations to just the loose end.
And if we do make that limit, we can paint our chain into a corner.

So is there anything helpful to do with a very straggly tree?  We
could treat it as a chain in the upward direction..

Well at least it avoids leader elections.  If we imbue the root of the
tree with decision authority and have some Plan B mechanism if the
root gets killed.

Well, let's put a parent pointer in HC and grow it just for fun, for
starters.  We'll take three bits for it, say

         2

      1  0  4

         3

with 5..7 available for special cases.

[58:

Wed Feb 27 07:54:06 2019 And what I was going to note a moment ago was
that if we only melt HC -> SC at corners, we can splice such an HC out
of the tree just within the event window.  Only the two adjacent
orthogonal HCs could possibly be depending on the corner HC.. wait
wait wait let's get our distance 2s and distance 4s sorted out here..

       .
      ...
     5.2.7
    .......
   ..1.0.4..
    .......
     6.3.8
      ...
       .

(Note we can turn those parent pointers into coords via
2*ew.getCoord((SiteNum) parentPointer) !)

So, yeah, that's nine possibilities taking four bits, if we're going
to have much flexibility.  With this scheme, as I was saying, we can
always melt a corner without breaking the tree, because if any of our
possible neighbors was pointing at us we can retarget them to our
parent and they can see that.

     q2.7
     q...
     q0.4
     qqqq

Given we're melting 0, its parent must have been 2,7, or 4, and its
only possible kids are 2, 7, and 4 as well.

Buut note our current melting rule doesn't extend that far:

  q__    ..@
  q@_ -> ._.
  qqq    ...

and with just that rule, we could be in a situation like:


    5.2.7
    qq...
     q0.4
     qqqq

but 4 and 5 cannot see each other so the tree could be broken if 0
melted.

But the bigger event window isn't recursive -- after we knock off the
corner we're stuck.

Could we have the HCs background swapping with each other trying to
make the tree a list?  Or trying to make the tree use only orthogonal
links?  If a diagonal link is a 'long bond' and an orthogonal link is
a 'short bond', we could melt any corner that has only short bonds..
[59:

Wed Feb 27 08:25:30 2019 So is there a nice little algebra of bond
shortening?  We're talking swapping entire HCs, I think, so that we
don't (in these operations anyway) change the tree structure, we're
just trying to 'relax' it so that it uses all othogonal bonds.  Now,
our growth rule IS only to orthogonal sites, so the grid will
initially be totally relaxed.

Sample relaxed tree:

     h<h h
     v v v
     h h h
     c ^ v
     h h<h


Melt NW corner:

     |-h h
     v v v
     h h h
     c ^ v
     h h<h

Now it's got one long bond. ..And I don't see any local way to relax that..
[60:

Wed Feb 27 09:05:35 2019 Are there any kind of moves we can make
locally?  It seems only in very restricted cases. [61:

Wed Feb 27 09:06:26 2019 What if, just for a minute, we consider
(effectively) ditching SC and doing something like a SwapLine to move
the HC?  If the HC could use the inter-HC gap for positioning and
movement slack, the HC can be the 'jelly' all by itself.[62:

Wed Feb 27 09:39:24 2019 After morning moment..  So for starters we
could leave the construction stuff rigid, as is.  Need to change the
misaligned maintenance stuff.  Suppose we had a five-state var saying
which way I've gone out of alignment..  Suppose we left behind some
ephemeral thing saying this is where I was?  Suppose we used a literal
SwapLine that anchors against IM?  Boils away if it loses contact with
IM or SL.  Boils away if there's IM in the heading direction.  Grows
in the orthogonal direction as long as there's adjacent IM.

And just suspends HC maintenance when it's around?

Let's try it.

:62]


:61]

:60]
:59]

:58]


:57]

:56]

:55]


:54]
[63:

Wed Feb 27 17:03:15 2019 Hmm seems like maybe a 'legitimate bug' here
in the splattr codegen, regarding beginSiteEval().  Right now it
appears that a SPLATRuleSet calls beginSiteEval() on each of its
directly-used SPLATKeyStates.  But the generated subclasses of
SPLATKeyState don't override beginSiteEval, so we go only to
SPLATKeyState.beginSiteEval(), and any keystates that are only
INDIRECTLY used don't get reset.

What we need is perhaps a single tree-walking beginSiteEval, or better
to have splattr codegen walk the tree and generate a custom
beginSiteEval for each subclass of SPLATKeyState, like it is already
doing for given and vote?  But however it's fixed, I think that's the
reason my

   mm    ..
   @x -> x@
   nn    ..

rule isn't firing..

:63]
[64:

Thu Feb 28 09:41:50 2019 Well, I did ultimately lose on trying to use
let m = s|a for the swapline advance rule, and ended up not only
expressing it in ulam, but then copy-pasting the ulam for keycode n.

So that was bad.  I suspect the issue was the code treats | in effect
as || -- like it skips the 'given a' if the 'given s' part works at a
site.  And somehow that matters, but the logic is so twisted and
unclear -- especially the caching code -- that I can't keep it
straight what the issues and arguments really are.

But there's really no time to try to fix that now.  We have to get to
movable cells and then cleanly reproducing cells PRONTO.

:64]
[65:

Thu Feb 28 09:47:22 2019 So at present we have a west SwapLine largely
working.  We have blocked SwapLine eventually randomly decaying and
that's causing troules because the line needs to be blocked in certain
cases, so we should get rid of that..[66:

Thu Feb 28 09:51:54 2019 Also, still need to get the HC to not detect
misalignment if SL are around..  and not even to try to grow at that
point.. [67:

Thu Feb 28 09:54:10 2019 About the nicest (at least living computation
/ programming-y) thing we've got so far is the idea of using virtual
functions in other elements to perform decision-making-on-the-fly
rather than pulling additional state forward into the forward actor.

We could think about extending that to more cases -- such as how many
'crowding votes' a given piece of content should have.  With such a
mechanism in hand we could have SwapLine count for extra crowding so
the membrane would tend to back off and give SL room to work.  The
current common blocking case is like:

     OI                     OOO
     OIH          or        OII
     OIS                    OIH
     OI S                   OIS

where the upper S can't extend the swapline upwards until there's room
behind the H to swap it backwards.  If S could say 'Give me space'
that would help.

[68:

Thu Feb 28 09:56:53 2019 Possible title angles:

Digital cell mechanics --
Extreme stigmergy via virtual functions

:68]

:67]

:66]

:65]
[69:

Thu Feb 28 10:09:26 2019 Wellll, fudge.  So we're actually pretty
fogged on the swapline-inside-membrane idea.  Because the cuteness of
the swapline is that it has a simple spatial invariant -- as long as
there's SL or IM in either x+-1 of each y+-1, the SL is consistent.

But maintaining that invariant requires that the IM NOT MOVE WHEN AN
SL IS RELYING ON IT.  So it's not enough that we were thinking the SL
might ask the IM to back off and make room -- we'd ALSO have to be
able to tell the IM not to move because we're counting on it as an
invariant.

So I think probably we should consider the swapline dead for this
application, for the moment.

Let's go back to thinking about the command & control from the
approximate center of the cell.  Like:

 - Once the cell is big enough, a cell near the center -- with its
   W,E distances all about equal, and also its N,S distances -- may
   declare itself the 'LEADER'.

 - If an HC detects an adjacent (4 ngb) LEADER, it becomes a
   'FOLLOWER'

 - If a LEADER detects an adjacent LEADER, their 'centerednesses'
   estimates are compared and the 'more centered' LEADER wins, with
   ties going to @.  The loser is demoted to a newly-created FOLLOWER.

[71: Thu Feb 28 11:18:02 2019 But maybe not this one?  The point of
building a 'quieter' execution environment is to support relatively
stable spatial structures, to use for computations involving more
state than can fit in a single atom.  The LEADER presumably wants to
use state in the FOLLOWERs, but if the LEADER flops around willy-nilly
that will be hard to do.  I think we should allow the leader to drift
off center at least somewhat.  :71]
 - If the LEADER detects that a FOLLOWER is _more_ centered than the
   LEADER, the LEADER swaps nearly completely with the FOLLOWER --
   except it does not swap the WNSE info.

[70:

Thu Feb 28 11:16:21 2019 The leader[72:

Thu Feb 28 11:21:45 2019 What if we say the followers are used to make
a redundant state vector.  Well what state do we expect the leader
will want to save?

LEADER tasks:

 - Issuing movement orders

 - Waiting for order completion or timeout

 - Holding the 'current mode'?

 - Performing mode switching?

[73:

Thu Feb 28 11:27:36 2019 So surely one story is the LEADER is the CPU
and program counter, and the FOLLOWER shared state is the program and
data.

So the WNSE distance gradients are an example of sensory data.  Those
are so important they're 'built into' the HC.  But we could have a
variety of other 'sense carriers' that head upgradient via the interHC
gaps and serve to ...wait

Suppose the FOLLOWERs represent a MODEL of the entire cell.

Each (perhaps 8ngb) FOLLOWER is in effect responsible for representing
(and eventually controlling) a quadrant (octant) of the cell.

The POINT is to make AN EVENT WINDOW-SIZED MODEL of something that's
MUCH BIGGER THAN AN EVENT WINDOW.  So we can weigh information from
far-flung corners of the cell and make an informed decision in a
single event.  (Albeit with necessarily somewhat stale information.)

[74:

Thu Feb 28 11:34:39 2019 So suppose a SenseCarrier works like this.
It has a sense coordinate that is set to 0 when it's created, and is
updated as the SC moves.  The SC does a stochastic hillclimb toward
the center, and when it comes within range of the (a?) FOLLOWER
responsible for that coordinate, the FOLLOWER integrates that data and
consumes the SC.

Doing 8 ngb followers could give us a better range of action, in the
sense that we could move in 8 dirs based on the 8ngb max freespace,
for example.  Although we could use ties or weighted choosing over
4ngb to achieve similar effects, I suppose.

So how could we get this cell to head towards free space?  We want to
be sensing outside the membrane for that.

Well, OM could record the outside density it sees, and perhaps do a
little low-pass smoothing on that.  Every so often IM could generate
and release an SC based on an adjacent OM density estimate.

Or could OM do edge detection?  Track apparent changes in density and
release SC preferentially or more frequently on changes?[75:

Thu Feb 28 11:47:27 2019 OK, well about to have to head off to the
shower and then busy busy in the world for a good chunk of the
afternoon, but can we first get down to some

TODO:

[78: Fri Mar  1 03:11:25 2019
DONE :78] - Add an Unsigned(2) mRole to HC.  0 == visitor, 1 == employee, 2 ==
   vice president, 3 == president.

[79: Fri Mar  1 03:11:33 2019 
DONE :79] - Get a centrally-located HC to declare itself P once the X and Y
   diameters reach say 5 and there's no other P around

 - Have 8ngb P's highlander it out as discussed

 - Have HC who see a 4ngb P declare itself VP

[maybe
 - Otherwise have HC who see a 4ngb VP declare itself employee

 - Otherwise have HC who see a 4ngb employee maybe declare themselves
   employee.  Like 50-50?

 - Otherwise have HC declare itself visitor
 ]

[80: Fri Mar  1 03:11:44 2019
DONE :80] - Have getColor identify the 'C-suite' occupants

 - Have OM measure and store exterior density excluding Res.  Store it
   in five bits?  Have the density denominator be not the event window
   size but only the stuff outside the OM?  Can we do that?  

 - Have IM average the exterior density of its local OM.  Store it in
   five bits too?

 - Have IM release a sense-density thing every so often

 - Create a Reporter class that climbs the corporate ladder and gets
   eaten by VPs.

:75]

:74]

:73]

:72]

:70]

:69]
[76:

Thu Feb 28 12:11:51 2019 Have to start packing up.  See yall on the
other side.

:76]
[77:

Fri Mar  1 00:14:46 2019 OK here we are.  Jeez now it's March.

:77]
[81:

Fri Mar  1 03:42:32 2019 So, we're kind of growing a 'nucleus' thing
now, although it doesn't do anything except exist.  What I'm realizing
is we are going to have an extra-cellular environment that's just
plastered full of Res, and that that's a hint.

We should have cellular operations routinely _consume_ Res.  Res
should not just be for transmuting into HC, it should power
everything, and the cell should not stop importing it just because
it's reached a mature size.

So I think QCyt or HC should have an mEnergy variable, that it runs
down by doing things, and charges up by consuming Res.  Or if we're
really disruptive, by transmuting Res into Ser or Waste or whatever we
want to call it.  The Ser would routinely be ejected from the cell,
where it would then gradually get converted into Res by the action of
DReg.

HC should send Ser downgradiant.  We'd like Ser to do that itself but
it seems kind of non-physical?  Maybe not.

Let's commit this nucleus stuff and then try some kind of waste
metabolism demo.

[82:

Fri Mar  1 03:48:53 2019 Although, looking at the movie I'm making
here, we are facing another leader conflict example.  Not sure how it
came to happen but it makes me want to be able to distinguish between
VPs that are looking to a leader and those that are just wondering if
they'll win the leader race.  Once someone is looking to a leader
everybody nearby needs to FOGGEN GET ON BOARD.

:82]

:81]
[83:

Fri Mar  1 04:34:04 2019 Leaving the previous movie accumulating.
Have some untested cuts at a 'mServing' data member in
HardCyt.. whups, the movie cell just exploded somehow.  Guess we
should kill that run and generate the movie..[84:

Fri Mar  1 04:44:57 2019 Well not clear.  DReg opened the membrane
long enough for QCyt to see OM is the guess.[85:

Fri Mar  1 13:23:24 2019 OK made an mServing hack but in the lunch run
never got a core developing.  [86:

Fri Mar  1 13:39:54 2019 OK this run got a core which is looking
pretty stable so far..

:86]

:85]

:84]

:83]
[87:

Fri Mar  1 14:21:07 2019 Well basically I think we have to try the
Res-metabolism story, even though of course we totally don't have
anything like the time to undertake such a massive rethink.

So we're going to commit this current snapshot (with barely-tested
mServing and all) and then try it.

:87]
[88:

Fri Mar  1 14:32:15 2019 OK, committed.  Res metabolism

TODO:

DONE - Decide if we're closing the loop 'materially' or only
   'energetically'.  In the latter case we don't need a 'Turd'
   particle.  We just consume the Res and let empty space represent
   lack of free energy.

   Well it seems the whole DReg concept pushes for 'energetic'
   closure, since it doesn't make any distinction between types of
   material (other than DReg itself).

   Let's at least start with energetic closure.  

[89: Sat Mar  2 01:02:50 2019 
DONE :89] - Make an Unary(2) mEnergy for QCyt.  Have a high-level rule that
   consumes Res with mEnergy < mEnergy.maxof.

[90: Sat Mar  2 01:02:58 2019
DONE:90] - Brighten QCyt getColor in proportion to mEnergy

[91: Sat Mar  2 01:03:13 2019
DONE:91] - Start making rules require mEnergy > 0 and start decrementin
   mEnergy when they fire.

:88]
[92:

Sat Mar  2 01:03:18 2019 So before nap we got to the idea of moving
the cell by having the leader move, and design the rest of the cell to
fall towards having the leader in the middle of the cell.

Right now, the 'mRole' provides a small amount of gradient around the
leader.  If we said something like "serving HC don't melt" that would
create a weak bias towards keeping the leader in the middle.

:92]

[93:

Sat Mar  2 04:25:57 2019 OK, so trying to drag the cell by moving the
leader, and preventing the c-suite from melting, is, at best, very
slow.  Kind of like the non-accelerated chain in the original 'large
object motion' video (Asymmetric diffusion of bonded structures in the
Movable Feast Machine, October 2011).

And, worse, once the core had gotten far enough off center, and the
cell gotten big enough, a second leader and emerged.  We're not ready
to deal with that.

So, if we ditch mRole as an explicit data member, and go to a second
x,y pairing for location relative to the leader, we can avoid the
second leader problem and likely accelerate movement significantly.

It 'just' means burning another non-trivial chunk of HC bits for a
second coordinate system.  Like 2xInt(5) perhaps?  2xInt(4) possibly?
And we soften/don't harden when we appear maxed on a coordinate?
Perhaps reserve Int(4).minof as an initial value and a code meaning
'no leader seen'?

What do these gradients relax to in absence of a leader to anchor
them?  I guess if a guy thinks he's distance one but doesn't see the
leader, he punts to 'no signal', and that just propagates?  How does
it propagate?  What does seeing 2 + 3 + nosignal, say, result in?

Answer: A nap.
[94:

Sat Mar  2 13:45:40 2019 OK so back from morning errands, including
picking up and trying out the M3x28mm socket cap screws for the case
corners.  They're a hair short, in principle 29mm might be better, but
30mm would be way long so..  They catch okay in the M3 nuts; as long
as they catch a few turns in the brass standoffs it'll be fine.

Anyway.[95:

Sat Mar  2 16:30:00 2019 So we will follow the mRole style and just
have a single Z value, instead of another set of X + Y values.  The
leader is the king of the hill and everybody else does max-1 on their
neighbors.  We'll do merely an Unsigned(3), say, for Z value, because
that still gives us a radius of 14 HC, which is about right for our
cells.

I'm wondering about having (at least) melted SC maintain enough state
that they can make a visit toward the center, and, after they get
close enough, then head for the nearest membrane wall.  A little
Unary(2) could be enough for that, or Unsigned(2) if we wanted a
little room to grow.

TODO:

[96: Sat Mar  2 16:43:22 2019 Well, first

DONE - Commit the Res metabolism stuff, then.. :96]

 - IMPLEMENT ALL THAT NOW NOW NOW

:95]

:94]

:93]
[97:

Sat Mar  2 16:51:04 2019 Well, it _seems_, just growing
HC.ulam:cROLE_BITS from 2u to 3u will do a fair chunk of the 'Z
gradient' redo.  Current question is whether the 'Bool mServing' is
really doing anything but confusing us?

:97]
[98:

Mon Mar  4 06:48:14 2019 Well the cell in the overnight run survived
past 600kAEPS, but didn't make a whole lot of progress heading east.
It developed a tile-spanning vertical front that looked hard to break
out of.  Suspicion is that this code

    u Bool inFreezingRange() {
    .   return getOutDistanceEstimate() <= Role.maxof/2u;
    . }

in HardCyt.splat is implicated -- with Role.maxof/2u == 7 and the HCs
spaced at period two, that's ~15 HCs taking ~30 sites, plus ~4 for the
membranes.  So we think we want to change it to:

    u Bool inFreezingRange() {
    .   return getOutDistanceEstimate() <= cCORPORATE_DIAMETER;
    . }

but wanted to commit the code associated with the run first.


:98]
