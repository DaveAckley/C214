{64}  -*- text -*-
[0:

Wed Feb 20 03:00:03 2019 OK time for an ALIFE19 paper.  The goal is
some kind of more structured reproduction than we saw in the 2018
'cancer cells' demo.  The plan, such as it is, is

(1) to build a quasicrystal-like molecule, something like the
    generalized crystals from 2014 (like
    https://www.youtube.com/watch?v=C6h3gvaKE7E ) and then

(2) get them to move with something like the asymmetric diffusion from
    2011 ( https://youtu.be/ykeNAmJ8pa4 ), and

(3) put them all in some C211-like bag (like 2018), for some good
    reason -- perhaps using the membrne to sense the environment and
    determine when conditions are plausible

(4) to perform a reproduction by having each guy in the crystal twin
    and then pull apart.

[1:

Wed Feb 20 03:26:34 2019 Well but when you write it all down like that
it seems like a lot of work for three weeks to a finished paper.

[2:

Wed Feb 20 03:27:10 2019 So let's get some quick breakdown TODO to get
us started.

[3: Wed Feb 20 06:12:43 2019
DONE Quasicrystal.splat  :3] - Build a telomere-controlled quasicrystal in SPLAT, requiring

[4: DONE  :4] - Get SPLAT set up and working in this directory

Foggit let's just do that right now and then come back.  (Although I'm
tempted to say: That builds from Res. [5: Wed Feb 20 06:13:12 2019
DONE ResQX.splat :5])

:2]

:1]

:0]
[6:

Wed Feb 20 06:13:39 2019 So we currently are going for a distance 3
spacing but that really does seem pretty loose -- and folks get lost
pretty easily at the edges.  We're going to put in a C211 membrane to
help reduce edge losses, but thinking we should try a period 2
membrane.. [8:

Wed Feb 20 06:36:00 2019 And I want to go Res-controlled instead of
telomere-controlled.  But do we have any evidence C211 can really
withstand DReg?

:8]

:6]
[7:

Wed Feb 20 06:35:13 2019 Also fixed some bad error reporting in
splattr..  Nice to be able to do that a little..

:7]
[9:

Thu Feb 21 10:31:51 2019 OK, now into ../code/201902211027-c213/ and
working on the membrane more.  Sort have IM burning in a pretty
rickety ring oscillator, and want something more robust.  Also have
a general "controllable membrane permeability" feature running at a
cost of 16 bits.[10:

Thu Feb 21 10:35:47 2019 But let's make the permeability less general
and cut it down to say four bits with a hardcoded permeability table.

:10]

Planning on ditching telomere controlled guts growth in favor of Res
contolled, using controlled permeability to turn on and off Res uptake
to modulate growth.

:9][11:

Thu Feb 21 10:38:04 2019 And what about making a 1D guts?  We do need
to get back to programmability eventually.

TODO:

 - Permeability table

 - mExport as well?

 - Push DReg away harder

 - Go for a 'standing gradient' on IM instead of a ring burn.

:11]
[12:

Thu Feb 21 11:02:28 2019 Hmm, on the permeability table, what if we
didn't store anything, but instead looked for some content on the fly
to ask if _this_ piece of membrane is open to _this_ possible import
_right now_?  Push the decision (and any associated storage cost) back
onto the content rather than pulling it forward to the membrane 'for
efficiency'.  But could we make a rule that would ever fire?

:12]
[13:

Fri Feb 22 03:37:24 2019 So we like the just-ask-QContent-on-the-fly
approach to the import decision.  It's still stigmergic, at least from
the membrane's point of view, but it's much more flexible than mere
geometry.

So, now we've moved on to ALIFE19/code/201902220336-grad/, and our
goal is to ditch the ring burn oscillator for a standing gradient
stabilizer. [14:

Sat Feb 23 07:13:52 2019 OK we made a gradient stabilizer, buuuut
given how much the membrane moves around, it's not all that stable
either.  In particular, it's to keep a single 'gradient anchor' point
alive as the membrane grows and shrinks.  You can get a relatively
durable but potentially unbounded _group_ of anchors, or you can have
a single anchor that gets killed pretty often..

[15:

Sat Feb 23 07:16:01 2019 We're thinking screw the membrane stuff for
now, and the next stop should be getting the interior goo to have a
hybrid solid/liquid' nature.  Content in 'solid' mode crystallizes
into a (bounded) side 2 square, while content in 'liquid' mode moves
in the odd phase empty spaces among the solid.

:15]

:14]

:13]
[16:

Sat Feb 23 11:44:32 2019 Moving these notes to ../code/C213/notes/ to
get into the noo! sekrit! mimburrs ownlee! repo.

:16]
[17:

Sat Feb 23 11:57:30 2019 OK.  So let's do solid crystallization first
and alone.

TODO:

[19: DONE Sat Feb 23 14:22:20 2019   :19] - Restart QX2 as QCyt.splat, make it a quark

[21: DONE, though only H does anything  :21] - Have HardCyt and SoftCyt as subclasses

[20: DONE  :20] - Make HardCyt grow from Res, forming a side 2 square lattice

 - Define HardCyt 'support' as the number of aligned HC neighbors.
   Have HC decay back to Res if it sees IM..[18: Sat Feb 23 12:09:11
   2019 Later, later.  Just get started now  :18]

:17][22:

Sat Feb 23 14:22:58 2019 OK, so we're building a H matrix now.

TODO:

[23: Sat Feb 23 16:48:54 2019
DONE for HardCyt, but WNSE == sitenum-1 :23] - Make NSEW distance estimators, measured in terms of H matrix
   cells.

[24: Sat Feb 23 16:48:59 2019
DONE :24] - Have H settle towards size/position info in terms of distance
   estimators

[25: Sun Feb 24 03:50:12 2019
DONE :25] - Stop importing Res once estimators exceed some threshold

:22]
[26:

Sun Feb 24 03:50:22 2019 OK so the distance estimators are workingish,
although (surprise) using them to limit cell growth has some
unexpected consequences.  Since they measure distance-from-IM, if we
can neck down the membrane in the middle, the cell can grow
in sort of a figure-8 shape and basically double its volume..

Just like if it was reproducing...

:26][27:

Sun Feb 24 03:54:43 2019 So more

TODO:

[30: Sun Feb 24 05:57:57 2019
DONE :30] - Extend distance estimator to do not just 1+nghb in the 'axis'
   direction but also max(nghb) in the 'orthogonal' direction.
   Worried that will lead to 'ghost distances' but we need to try
   coupling across rows/columns somehow.

[32: Sun Feb 24 08:12:05 2019 Can even export DReg and import Res in one event!
DONE :32] - Export DReg.  Despite everything it managed to get into the cells
   on the evening/night long-run test.

 - Review/debug QMembrane rules.  We observed crosses and chipped caps
   in the long run.  We're not sure if we broke something that used to
   prevent/fix them, or if (we suspect) DReg is implicated in their
   formation, but either way nothing seemed to degrade or repair them.

            IO                   OO
    Cross:  OI    Chipped cap:   OIO

    We'd like chipped caps to fill:  oO_ -> ..O
    with o isa OM and O isa OM.      oIO    ...

                                      ___     ...
    At least, if there's nothing     oO__ -> ..O.
    confounding, perhaps like:       oIO_    ....

    Really not clear what to do about crosses but let's take another
    look.


 - Also saw stable edge-of-universe stubs we'd like to get rid of:

               ddd
    Edge stub: OIO   # d

 - (Probably,) Ditch HardCyt & SoftCyt as types in favor of just QCyt
   with a Bool mIsHard.  We're going to want to melt and freeze QCyt
   without losing all their state.

:27]
[28:

Sun Feb 24 04:53:42 2019 So we had restricted ourselves to
'\symmetries rotations' to keep our sanity, but combining that with
our getWestIndex and getNorthIndex concepts actually meant our 'max in
the orthogonal direction' implementation missed cases where a flip is
required to make 'north' be counter-clockwise to west.

So we just finishing rebuilding with '\symmetries all' and we're
predicting it will work better.[29:

Sun Feb 24 05:03:46 2019 Playing with that (it's working as we
expected) and just noticed that two away from a HardCyt it might be an
OM, and we better accept that as a basis for 0 distance to membrane!

:29]

:28]
[31:

Sun Feb 24 05:58:12 2019 So, the 1+axis, max(ortho) concept seems to
work pretty well and with some interesting properties.

 - Yes, there can be conflicts between trusting your neighbors
   estimates vs your own observations.  With one symmetry you may see,
   say membrane to the west, and so set your west distance, while with
   another symmetry you end up maxing with your north neighbor's west
   and get a non-zero score.

 - And those conflicts absolutely do cause instabilities in distance
   estimates, whenever a given HC is on a row or column that is not,
   in fact, the max width or height.

 - But we do _not_ see 'ghost' or zombie distances persisting
   indefinitely, so long as the main connectivity of the grid is
   intact.  To the contrary estimates quite quickly to only vary
   between plausible values given the current membrane shape.

 - (Now, if a DReg gets in and starts punching holes, that can
   eliminate some estimate propagation channels and leave bad
   estimates hanging in some cells.  But we're talking dementia by
   then in any case.)

 - And for the folk, if any, that are on a max width row and a max
   height column, their distance estimates are rock solid -- and such
   folk tend to be toward the middle of the cell, and thus plausible
   candidates for elevating to some more privileged status.

:31]
[33:

Sun Feb 24 09:48:01 2019 OK, so, doing a longer run we still see DReg
managing to raise havoc, sufficiently to disrupt the membrane an let
the cyt out which then plasters the universe (along with rogue
membrane biofilms).

So it's time to implement the ripcord for these guys, giving them a
collective identity tag and the ability to trigger apoptosis if things
go too far wrong.  We're going to have membrane just vanish while Cyt
will decay back to Res even though those are pretty inconsistent
stories relative to conservation of 'matter'.  (But, we're going to
say that such 'conservation laws' are design choices, not givens, in a
hosted physics.)

(We also still need to fix at least the chipped caps, because they're
still happening and they seem fixable.)

:33]
[34:

Sun Feb 24 09:56:27 2019 Buut what if we _don't_ have an identity tag?
What if we go on spatial grounds?  Triggered Cyt destroys all the Cyt
it can see; if that stretches into (what had been) another cell well
too bad for that other cell -- it shouldn't have gotten so close.

We'll need to deal with membrane decay separately, but we can think of
conditions for Cyt to punch out:

 (1) Cyt immediately adjacent to OM

 (2) Any Cyt mDistances reaches Distance.maxof

[35:

Sun Feb 24 10:00:52 2019 Let's see how far we can get on clean dying
without QID.splat..
[36:

Sun Feb 24 10:02:21 2019 Well, for that, some

TODO:

[37: Sun Feb 24 10:53:35 2019
DONE :37] - Rip the vestiges of telomere out of QCyt

[38: Sun Feb 24 10:53:40 2019
DONE :38] - Add a QCyt.mDie Bool propagating at max velocity

[39: Sun Feb 24 10:53:55 2019
DONE :39] - Get cases :34: 1-2 going

:36]
:35]

:34]
[40:

Sun Feb 24 10:54:08 2019 OK, so now we need QMembrane death, because
on oversize death we have residual Res that keeps the membrane from
collapsing all the way.

..but wait, we don't have enough residual Res, our HardCyt is not
decaying properly; why not?

:40]
[41:

Mon Feb 25 03:51:23 2019 OK so we have both HardCyt and QMembrane
decaying in reasonably plausible ways.  Still need to deal with
chipped caps; let's go for that.[42:

Mon Feb 25 03:53:35 2019 OK, so, why doesn't 'Put your cap on' already
deal with this?  In a 'given @ isa InnerMembrane' ruleset, we have
this:

 _____     .....
 __oo_     .o...
  o@o  ->   ...     # Put your cap on

Ah I guess it's because of the _ at LHS (4,1)?

..Wait, I guess the issue really isn't as specific as a chipped cap like

  _oo
  o@o

it's more like a 'dinged corner'

  _o     oo
  o@ ->  o@

except isn't that an awful small pattern to deploy comfortably?
How could that rule really be safe?

        oo.oo
  _oo   oo_oi
  oio   iioii
  oi     ioi

[43:

Mon Feb 25 04:09:31 2019 Well, trying it

  _o     o.
  o@ ->  ..

Does that mean we want to try

  _i     i.
  i@ ->  ..

in the OM stabilization section?
[44:

Mon Feb 25 04:11:02 2019 Well, trying both.. But They Can't Be Right
They Are Too General![45:

Mon Feb 25 04:44:31 2019 Well, they might be Too General but so far
they seem to be fitting in with no ill effects..  Hard to believe we
didn't have them before.  Perhaps they used to be covered by something
we changed recently.

:45]

:44]

:43]
:42]

:41]
[46:

Mon Feb 25 08:54:16 2019 OK well I guess we can claim clean dying at
this point.  We'd like to defend against DReg a little better than we
are so far -- cells seem to be dying within a few or several hours of
runtime -- but we'll revisit that later.  Thinking about a OM-mediated
fringe of external sensors/protectors that might push out the
controlled radius.

:46][47:

Mon Feb 25 09:17:33 2019 So.  SoftCyt?  How do we go at it.  I confess
I'd rather keep HC and SC as separate types[48:

Mon Feb 25 10:02:14 2019 OK let's keep them separate.  How do we
transfer base class QCyt state from an instance of one to a newly
created instance of the other.  What's our situation on constructors
in ulam these days?[49: Tue Feb 26 15:04:06 2019 Done using Self(..)?

Ooh, the uAARM (ulam Appendix A Reference Manual) says I can put
arguments after an instanceof operator.  That should give me a base
class transfer route, yes no yes?

[50:

Tue Feb 26 15:10:07 2019 Could we also offer $Self as a SPLAT
mechanism to provide the 'top-level' Self to all rule sets?  It would
expand to the actual class name, rather than to (ulam-level) 'Self',
so it would get around the 'rule sets are different classes' issue.

:50]

:49]

:48]

:47]
[51:

Wed Feb 27 05:55:09 2019 Finally got a full-on sleep.  So to transfer
state HardCyt<->SoftCyt, can't we just do broadside parallel
assignment of the base class type?

  Base A, data member a1, a2
  Sub B isa A, data member b1
  Sub C isa A, data member c1

  B b; b.a1 = 9; b.a2 = 10; b.b1 = 11;
  C c; c.c1 = 11; // c.a1 == 0; c.a2 == 0;
  ((A&) c) = (A&) b;
  // now c.a1 == 9; c.a2 == 10; c.c1 == 11; right?

[52:

Wed Feb 27 06:06:52 2019 Well it's saying

  B initFrom(A& suba) {
    B b;
    ((A&) b) = suba;
      ^
./Base.ulam:9:7: ERROR: Explicit Reference casts (Type&) are valid for reference variable initialization (including function call arguments); not in this context.

[53:

Wed Feb 27 06:26:59 2019 Buuut this works..

  Unsigned(4) c1 = 9;
  B initFrom(Base& base) {
    B b;
    Base& r = (Base&) b;
    r = base;
    return b;
  }

so yes, we can do parallel assignment to all the base class state via
a reference-to-base

:53]

:52]

:51]
[54:

Wed Feb 27 06:40:03 2019 OK so we have 'SoftCyt soften() {..}' in
HardCyt and 'HardCyt harden() {..}' in SoftCyt, as yet untested but
plausible.  We need some QCyt state to be passed around and I'm
thinking let's toss together some little tag-value thing and have a
few of those at QCyt level.  Hard and soft might have other tags of
their own but we need to strike at a cell-wide associative pool of
knowledge real soon now, so...

8 bit tag-val?  3 tag + 5 val?  Parametrize it of course but..  Well
let's just start QTag?  Where's the value?  QTuple?  That's any
arity.  QAttr?  QProperty?

Well, what operations do we want our collective pool of t-vs to have?
Read and write?  That's pretty high level.  How about 'amplify' and
'attenuate'.  Then search.

We'd like to store a not-huge set of tag-values robustly in a
distributed, shifting pool of tag-value 'slots', and get nice
properties from the collection like:

 - Blocking reads: Can post a request for the value of a tag and then
   'suspend the thread' until that comes back.

So we're building a threaded machine on top of these TVs?

Perhaps it's time to actually go programmable and say these TVs can
read other TVs and request and control stuff?  Is there a
minimal-minimal way to think about that to get started?  After all we
don't even have cell mobility actually implemented yet.

 - Votes and quorum calls.  Make a collective decision based on how
   much support there is for something.

[55:

Wed Feb 27 07:08:54 2019 I think we need to NOT go full-on tag value
in the sense of expecting tag semantics to be immutable across the
entire collective.  We WANT to continue to use spatial locality to
resolve aliased/ambiguous tag meanings locally.

For example, suppose we used UMod tags to create a 1D sequence of
TVs within the HCs.  Anybody in the event window can have the next tag
in the sequence, but the sequence itself can stretch beyond the
event window and the tags (of course) repeat with the period of the
UMod.

So like if we put just two TVs per HC, then we could see up to 10 TVs
in an event window, so a UMod(4) tag would have slack beyond..
[56:

Wed Feb 27 07:25:21 2019 Simplify.  How about just a linear chain of
HCs, with a next and prev ptr based on direction?  Perhaps SCs could
chain based on tag identity, and that way we could freeze and melt a
1D QCyt sequence by mapping back and forth between location-based (HC
positions) and content-based (SC tags) chaining.  We'd also need
HC<->SC interface mechanisms at the melting and freezing sequence
ends, that would have one location-based pointer and one tag-based
pointer.

SC would have to not stray beyond the ..if anybody ..

So we're reinventing bonds here, step by step.  Not that reinvention
is a bad thing, oh no no.  But we should be aware of the bond
attractor as we consider our moves here.

[57:

Wed Feb 27 07:35:19 2019 So we can build a 1D HC chain using history.
The seed creates a "5'" HC end (though we won't call it that) and
subsequent HC creations (always performed by an existing HC) add on at
the "3'" end.  But, just like in the 2D printer, that creates a tree,
not a chain, unless we limit the 3' creations to just the loose end.
And if we do make that limit, we can paint our chain into a corner.

So is there anything helpful to do with a very straggly tree?  We
could treat it as a chain in the upward direction..

Well at least it avoids leader elections.  If we imbue the root of the
tree with decision authority and have some Plan B mechanism if the
root gets killed.

Well, let's put a parent pointer in HC and grow it just for fun, for
starters.  We'll take three bits for it, say

         2

      1  0  4

         3

with 5..7 available for special cases.

[58:

Wed Feb 27 07:54:06 2019 And what I was going to note a moment ago was
that if we only melt HC -> SC at corners, we can splice such an HC out
of the tree just within the event window.  Only the two adjacent
orthogonal HCs could possibly be depending on the corner HC.. wait
wait wait let's get our distance 2s and distance 4s sorted out here..

       .
      ...
     5.2.7
    .......
   ..1.0.4..
    .......
     6.3.8
      ...
       .

(Note we can turn those parent pointers into coords via
2*ew.getCoord((SiteNum) parentPointer) !)

So, yeah, that's nine possibilities taking four bits, if we're going
to have much flexibility.  With this scheme, as I was saying, we can
always melt a corner without breaking the tree, because if any of our
possible neighbors was pointing at us we can retarget them to our
parent and they can see that.

     q2.7
     q...
     q0.4
     qqqq

Given we're melting 0, its parent must have been 2,7, or 4, and its
only possible kids are 2, 7, and 4 as well.

Buut note our current melting rule doesn't extend that far:

  q__    ..@
  q@_ -> ._.
  qqq    ...

and with just that rule, we could be in a situation like:


    5.2.7
    qq...
     q0.4
     qqqq

but 4 and 5 cannot see each other so the tree could be broken if 0
melted.

But the bigger event window isn't recursive -- after we knock off the
corner we're stuck.

Could we have the HCs background swapping with each other trying to
make the tree a list?  Or trying to make the tree use only orthogonal
links?  If a diagonal link is a 'long bond' and an orthogonal link is
a 'short bond', we could melt any corner that has only short bonds..
[59:

Wed Feb 27 08:25:30 2019 So is there a nice little algebra of bond
shortening?  We're talking swapping entire HCs, I think, so that we
don't (in these operations anyway) change the tree structure, we're
just trying to 'relax' it so that it uses all othogonal bonds.  Now,
our growth rule IS only to orthogonal sites, so the grid will
initially be totally relaxed.

Sample relaxed tree:

     h<h h
     v v v
     h h h
     c ^ v
     h h<h


Melt NW corner:

     |-h h
     v v v
     h h h
     c ^ v
     h h<h

Now it's got one long bond. ..And I don't see any local way to relax that..
[60:

Wed Feb 27 09:05:35 2019 Are there any kind of moves we can make
locally?  It seems only in very restricted cases. [61:

Wed Feb 27 09:06:26 2019 What if, just for a minute, we consider
(effectively) ditching SC and doing something like a SwapLine to move
the HC?  If the HC could use the inter-HC gap for positioning and
movement slack, the HC can be the 'jelly' all by itself.[62:

Wed Feb 27 09:39:24 2019 After morning moment..  So for starters we
could leave the construction stuff rigid, as is.  Need to change the
misaligned maintenance stuff.  Suppose we had a five-state var saying
which way I've gone out of alignment..  Suppose we left behind some
ephemeral thing saying this is where I was?  Suppose we used a literal
SwapLine that anchors against IM?  Boils away if it loses contact with
IM or SL.  Boils away if there's IM in the heading direction.  Grows
in the orthogonal direction as long as there's adjacent IM.

And just suspends HC maintenance when it's around?

Let's try it.

:62]


:61]

:60]
:59]

:58]


:57]

:56]

:55]


:54]
[63:

Wed Feb 27 17:03:15 2019 Hmm seems like maybe a 'legitimate bug' here
in the splattr codegen, regarding beginSiteEval().  Right now it
appears that a SPLATRuleSet calls beginSiteEval() on each of its
directly-used SPLATKeyStates.  But the generated subclasses of
SPLATKeyState don't override beginSiteEval, so we go only to
SPLATKeyState.beginSiteEval(), and any keystates that are only
INDIRECTLY used don't get reset.

What we need is perhaps a single tree-walking beginSiteEval, or better
to have splattr codegen walk the tree and generate a custom
beginSiteEval for each subclass of SPLATKeyState, like it is already
doing for given and vote?  But however it's fixed, I think that's the
reason my

   mm    ..
   @x -> x@
   nn    ..

rule isn't firing..

:63]
