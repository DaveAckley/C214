{181}  -*- text -*-
[0:

Wed Feb 20 03:00:03 2019 OK time for an ALIFE19 paper.  The goal is
some kind of more structured reproduction than we saw in the 2018
'cancer cells' demo.  The plan, such as it is, is

(1) to build a quasicrystal-like molecule, something like the
    generalized crystals from 2014 (like
    https://www.youtube.com/watch?v=C6h3gvaKE7E ) and then

(2) get them to move with something like the asymmetric diffusion from
    2011 ( https://youtu.be/ykeNAmJ8pa4 ), and

(3) put them all in some C211-like bag (like 2018), for some good
    reason -- perhaps using the membrne to sense the environment and
    determine when conditions are plausible

(4) to perform a reproduction by having each guy in the crystal twin
    and then pull apart.

[1:

Wed Feb 20 03:26:34 2019 Well but when you write it all down like that
it seems like a lot of work for three weeks to a finished paper.

[2:

Wed Feb 20 03:27:10 2019 So let's get some quick breakdown TODO to get
us started.

[3: Wed Feb 20 06:12:43 2019
DONE Quasicrystal.splat  :3] - Build a telomere-controlled quasicrystal in SPLAT, requiring

[4: DONE  :4] - Get SPLAT set up and working in this directory

Foggit let's just do that right now and then come back.  (Although I'm
tempted to say: That builds from Res. [5: Wed Feb 20 06:13:12 2019
DONE ResQX.splat :5])

:2]

:1]

:0]
[6:

Wed Feb 20 06:13:39 2019 So we currently are going for a distance 3
spacing but that really does seem pretty loose -- and folks get lost
pretty easily at the edges.  We're going to put in a C211 membrane to
help reduce edge losses, but thinking we should try a period 2
membrane.. [8:

Wed Feb 20 06:36:00 2019 And I want to go Res-controlled instead of
telomere-controlled.  But do we have any evidence C211 can really
withstand DReg?

:8]

:6]
[7:

Wed Feb 20 06:35:13 2019 Also fixed some bad error reporting in
splattr..  Nice to be able to do that a little..

:7]
[9:

Thu Feb 21 10:31:51 2019 OK, now into ../code/201902211027-c213/ and
working on the membrane more.  Sort have IM burning in a pretty
rickety ring oscillator, and want something more robust.  Also have
a general "controllable membrane permeability" feature running at a
cost of 16 bits.[10:

Thu Feb 21 10:35:47 2019 But let's make the permeability less general
and cut it down to say four bits with a hardcoded permeability table.

:10]

Planning on ditching telomere controlled guts growth in favor of Res
contolled, using controlled permeability to turn on and off Res uptake
to modulate growth.

:9][11:

Thu Feb 21 10:38:04 2019 And what about making a 1D guts?  We do need
to get back to programmability eventually.

TODO:

 - Permeability table

 - mExport as well?

 - Push DReg away harder

 - Go for a 'standing gradient' on IM instead of a ring burn.

:11]
[12:

Thu Feb 21 11:02:28 2019 Hmm, on the permeability table, what if we
didn't store anything, but instead looked for some content on the fly
to ask if _this_ piece of membrane is open to _this_ possible import
_right now_?  Push the decision (and any associated storage cost) back
onto the content rather than pulling it forward to the membrane 'for
efficiency'.  But could we make a rule that would ever fire?

:12]
[13:

Fri Feb 22 03:37:24 2019 So we like the just-ask-QContent-on-the-fly
approach to the import decision.  It's still stigmergic, at least from
the membrane's point of view, but it's much more flexible than mere
geometry.

So, now we've moved on to ALIFE19/code/201902220336-grad/, and our
goal is to ditch the ring burn oscillator for a standing gradient
stabilizer. [14:

Sat Feb 23 07:13:52 2019 OK we made a gradient stabilizer, buuuut
given how much the membrane moves around, it's not all that stable
either.  In particular, it's to keep a single 'gradient anchor' point
alive as the membrane grows and shrinks.  You can get a relatively
durable but potentially unbounded _group_ of anchors, or you can have
a single anchor that gets killed pretty often..

[15:

Sat Feb 23 07:16:01 2019 We're thinking screw the membrane stuff for
now, and the next stop should be getting the interior goo to have a
hybrid solid/liquid' nature.  Content in 'solid' mode crystallizes
into a (bounded) side 2 square, while content in 'liquid' mode moves
in the odd phase empty spaces among the solid.

:15]

:14]

:13]
[16:

Sat Feb 23 11:44:32 2019 Moving these notes to ../code/C213/notes/ to
get into the noo! sekrit! mimburrs ownlee! repo.

:16]
[17:

Sat Feb 23 11:57:30 2019 OK.  So let's do solid crystallization first
and alone.

TODO:

[19: DONE Sat Feb 23 14:22:20 2019   :19] - Restart QX2 as QCyt.splat, make it a quark

[21: DONE, though only H does anything  :21] - Have HardCyt and SoftCyt as subclasses

[20: DONE  :20] - Make HardCyt grow from Res, forming a side 2 square lattice

 - Define HardCyt 'support' as the number of aligned HC neighbors.
   Have HC decay back to Res if it sees IM..[18: Sat Feb 23 12:09:11
   2019 Later, later.  Just get started now  :18]

:17][22:

Sat Feb 23 14:22:58 2019 OK, so we're building a H matrix now.

TODO:

[23: Sat Feb 23 16:48:54 2019
DONE for HardCyt, but WNSE == sitenum-1 :23] - Make NSEW distance estimators, measured in terms of H matrix
   cells.

[24: Sat Feb 23 16:48:59 2019
DONE :24] - Have H settle towards size/position info in terms of distance
   estimators

[25: Sun Feb 24 03:50:12 2019
DONE :25] - Stop importing Res once estimators exceed some threshold

:22]
[26:

Sun Feb 24 03:50:22 2019 OK so the distance estimators are workingish,
although (surprise) using them to limit cell growth has some
unexpected consequences.  Since they measure distance-from-IM, if we
can neck down the membrane in the middle, the cell can grow
in sort of a figure-8 shape and basically double its volume..

Just like if it was reproducing...

:26][27:

Sun Feb 24 03:54:43 2019 So more

TODO:

[30: Sun Feb 24 05:57:57 2019
DONE :30] - Extend distance estimator to do not just 1+nghb in the 'axis'
   direction but also max(nghb) in the 'orthogonal' direction.
   Worried that will lead to 'ghost distances' but we need to try
   coupling across rows/columns somehow.

[32: Sun Feb 24 08:12:05 2019 Can even export DReg and import Res in one event!
DONE :32] - Export DReg.  Despite everything it managed to get into the cells
   on the evening/night long-run test.

 - Review/debug QMembrane rules.  We observed crosses and chipped caps
   in the long run.  We're not sure if we broke something that used to
   prevent/fix them, or if (we suspect) DReg is implicated in their
   formation, but either way nothing seemed to degrade or repair them.

            IO                   OO
    Cross:  OI    Chipped cap:   OIO

    We'd like chipped caps to fill:  oO_ -> ..O
    with o isa OM and O isa OM.      oIO    ...

                                      ___     ...
    At least, if there's nothing     oO__ -> ..O.
    confounding, perhaps like:       oIO_    ....

    Really not clear what to do about crosses but let's take another
    look.


 - Also saw stable edge-of-universe stubs we'd like to get rid of:

               ddd
    Edge stub: OIO   # d

 - (Probably,) Ditch HardCyt & SoftCyt as types in favor of just QCyt
   with a Bool mIsHard.  We're going to want to melt and freeze QCyt
   without losing all their state.

:27]
[28:

Sun Feb 24 04:53:42 2019 So we had restricted ourselves to
'\symmetries rotations' to keep our sanity, but combining that with
our getWestIndex and getNorthIndex concepts actually meant our 'max in
the orthogonal direction' implementation missed cases where a flip is
required to make 'north' be counter-clockwise to west.

So we just finishing rebuilding with '\symmetries all' and we're
predicting it will work better.[29:

Sun Feb 24 05:03:46 2019 Playing with that (it's working as we
expected) and just noticed that two away from a HardCyt it might be an
OM, and we better accept that as a basis for 0 distance to membrane!

:29]

:28]
[31:

Sun Feb 24 05:58:12 2019 So, the 1+axis, max(ortho) concept seems to
work pretty well and with some interesting properties.

 - Yes, there can be conflicts between trusting your neighbors
   estimates vs your own observations.  With one symmetry you may see,
   say membrane to the west, and so set your west distance, while with
   another symmetry you end up maxing with your north neighbor's west
   and get a non-zero score.

 - And those conflicts absolutely do cause instabilities in distance
   estimates, whenever a given HC is on a row or column that is not,
   in fact, the max width or height.

 - But we do _not_ see 'ghost' or zombie distances persisting
   indefinitely, so long as the main connectivity of the grid is
   intact.  To the contrary estimates quite quickly to only vary
   between plausible values given the current membrane shape.

 - (Now, if a DReg gets in and starts punching holes, that can
   eliminate some estimate propagation channels and leave bad
   estimates hanging in some cells.  But we're talking dementia by
   then in any case.)

 - And for the folk, if any, that are on a max width row and a max
   height column, their distance estimates are rock solid -- and such
   folk tend to be toward the middle of the cell, and thus plausible
   candidates for elevating to some more privileged status.

:31]
[33:

Sun Feb 24 09:48:01 2019 OK, so, doing a longer run we still see DReg
managing to raise havoc, sufficiently to disrupt the membrane an let
the cyt out which then plasters the universe (along with rogue
membrane biofilms).

So it's time to implement the ripcord for these guys, giving them a
collective identity tag and the ability to trigger apoptosis if things
go too far wrong.  We're going to have membrane just vanish while Cyt
will decay back to Res even though those are pretty inconsistent
stories relative to conservation of 'matter'.  (But, we're going to
say that such 'conservation laws' are design choices, not givens, in a
hosted physics.)

(We also still need to fix at least the chipped caps, because they're
still happening and they seem fixable.)

:33]
[34:

Sun Feb 24 09:56:27 2019 Buut what if we _don't_ have an identity tag?
What if we go on spatial grounds?  Triggered Cyt destroys all the Cyt
it can see; if that stretches into (what had been) another cell well
too bad for that other cell -- it shouldn't have gotten so close.

We'll need to deal with membrane decay separately, but we can think of
conditions for Cyt to punch out:

 (1) Cyt immediately adjacent to OM

 (2) Any Cyt mDistances reaches Distance.maxof

[35:

Sun Feb 24 10:00:52 2019 Let's see how far we can get on clean dying
without QID.splat..
[36:

Sun Feb 24 10:02:21 2019 Well, for that, some

TODO:

[37: Sun Feb 24 10:53:35 2019
DONE :37] - Rip the vestiges of telomere out of QCyt

[38: Sun Feb 24 10:53:40 2019
DONE :38] - Add a QCyt.mDie Bool propagating at max velocity

[39: Sun Feb 24 10:53:55 2019
DONE :39] - Get cases :34: 1-2 going

:36]
:35]

:34]
[40:

Sun Feb 24 10:54:08 2019 OK, so now we need QMembrane death, because
on oversize death we have residual Res that keeps the membrane from
collapsing all the way.

..but wait, we don't have enough residual Res, our HardCyt is not
decaying properly; why not?

:40]
[41:

Mon Feb 25 03:51:23 2019 OK so we have both HardCyt and QMembrane
decaying in reasonably plausible ways.  Still need to deal with
chipped caps; let's go for that.[42:

Mon Feb 25 03:53:35 2019 OK, so, why doesn't 'Put your cap on' already
deal with this?  In a 'given @ isa InnerMembrane' ruleset, we have
this:

 _____     .....
 __oo_     .o...
  o@o  ->   ...     # Put your cap on

Ah I guess it's because of the _ at LHS (4,1)?

..Wait, I guess the issue really isn't as specific as a chipped cap like

  _oo
  o@o

it's more like a 'dinged corner'

  _o     oo
  o@ ->  o@

except isn't that an awful small pattern to deploy comfortably?
How could that rule really be safe?

        oo.oo
  _oo   oo_oi
  oio   iioii
  oi     ioi

[43:

Mon Feb 25 04:09:31 2019 Well, trying it

  _o     o.
  o@ ->  ..

Does that mean we want to try

  _i     i.
  i@ ->  ..

in the OM stabilization section?
[44:

Mon Feb 25 04:11:02 2019 Well, trying both.. But They Can't Be Right
They Are Too General![45:

Mon Feb 25 04:44:31 2019 Well, they might be Too General but so far
they seem to be fitting in with no ill effects..  Hard to believe we
didn't have them before.  Perhaps they used to be covered by something
we changed recently.

:45]

:44]

:43]
:42]

:41]
[46:

Mon Feb 25 08:54:16 2019 OK well I guess we can claim clean dying at
this point.  We'd like to defend against DReg a little better than we
are so far -- cells seem to be dying within a few or several hours of
runtime -- but we'll revisit that later.  Thinking about a OM-mediated
fringe of external sensors/protectors that might push out the
controlled radius.

:46][47:

Mon Feb 25 09:17:33 2019 So.  SoftCyt?  How do we go at it.  I confess
I'd rather keep HC and SC as separate types[48:

Mon Feb 25 10:02:14 2019 OK let's keep them separate.  How do we
transfer base class QCyt state from an instance of one to a newly
created instance of the other.  What's our situation on constructors
in ulam these days?[49: Tue Feb 26 15:04:06 2019 Done using Self(..)?

Ooh, the uAARM (ulam Appendix A Reference Manual) says I can put
arguments after an instanceof operator.  That should give me a base
class transfer route, yes no yes?

[50:

Tue Feb 26 15:10:07 2019 Could we also offer $Self as a SPLAT
mechanism to provide the 'top-level' Self to all rule sets?  It would
expand to the actual class name, rather than to (ulam-level) 'Self',
so it would get around the 'rule sets are different classes' issue.

:50]

:49]

:48]

:47]
[51:

Wed Feb 27 05:55:09 2019 Finally got a full-on sleep.  So to transfer
state HardCyt<->SoftCyt, can't we just do broadside parallel
assignment of the base class type?

  Base A, data member a1, a2
  Sub B isa A, data member b1
  Sub C isa A, data member c1

  B b; b.a1 = 9; b.a2 = 10; b.b1 = 11;
  C c; c.c1 = 11; // c.a1 == 0; c.a2 == 0;
  ((A&) c) = (A&) b;
  // now c.a1 == 9; c.a2 == 10; c.c1 == 11; right?

[52:

Wed Feb 27 06:06:52 2019 Well it's saying

  B initFrom(A& suba) {
    B b;
    ((A&) b) = suba;
      ^
./Base.ulam:9:7: ERROR: Explicit Reference casts (Type&) are valid for reference variable initialization (including function call arguments); not in this context.

[53:

Wed Feb 27 06:26:59 2019 Buuut this works..

  Unsigned(4) c1 = 9;
  B initFrom(Base& base) {
    B b;
    Base& r = (Base&) b;
    r = base;
    return b;
  }

so yes, we can do parallel assignment to all the base class state via
a reference-to-base

:53]

:52]

:51]
[54:

Wed Feb 27 06:40:03 2019 OK so we have 'SoftCyt soften() {..}' in
HardCyt and 'HardCyt harden() {..}' in SoftCyt, as yet untested but
plausible.  We need some QCyt state to be passed around and I'm
thinking let's toss together some little tag-value thing and have a
few of those at QCyt level.  Hard and soft might have other tags of
their own but we need to strike at a cell-wide associative pool of
knowledge real soon now, so...

8 bit tag-val?  3 tag + 5 val?  Parametrize it of course but..  Well
let's just start QTag?  Where's the value?  QTuple?  That's any
arity.  QAttr?  QProperty?

Well, what operations do we want our collective pool of t-vs to have?
Read and write?  That's pretty high level.  How about 'amplify' and
'attenuate'.  Then search.

We'd like to store a not-huge set of tag-values robustly in a
distributed, shifting pool of tag-value 'slots', and get nice
properties from the collection like:

 - Blocking reads: Can post a request for the value of a tag and then
   'suspend the thread' until that comes back.

So we're building a threaded machine on top of these TVs?

Perhaps it's time to actually go programmable and say these TVs can
read other TVs and request and control stuff?  Is there a
minimal-minimal way to think about that to get started?  After all we
don't even have cell mobility actually implemented yet.

 - Votes and quorum calls.  Make a collective decision based on how
   much support there is for something.

[55:

Wed Feb 27 07:08:54 2019 I think we need to NOT go full-on tag value
in the sense of expecting tag semantics to be immutable across the
entire collective.  We WANT to continue to use spatial locality to
resolve aliased/ambiguous tag meanings locally.

For example, suppose we used UMod tags to create a 1D sequence of
TVs within the HCs.  Anybody in the event window can have the next tag
in the sequence, but the sequence itself can stretch beyond the
event window and the tags (of course) repeat with the period of the
UMod.

So like if we put just two TVs per HC, then we could see up to 10 TVs
in an event window, so a UMod(4) tag would have slack beyond..
[56:

Wed Feb 27 07:25:21 2019 Simplify.  How about just a linear chain of
HCs, with a next and prev ptr based on direction?  Perhaps SCs could
chain based on tag identity, and that way we could freeze and melt a
1D QCyt sequence by mapping back and forth between location-based (HC
positions) and content-based (SC tags) chaining.  We'd also need
HC<->SC interface mechanisms at the melting and freezing sequence
ends, that would have one location-based pointer and one tag-based
pointer.

SC would have to not stray beyond the ..if anybody ..

So we're reinventing bonds here, step by step.  Not that reinvention
is a bad thing, oh no no.  But we should be aware of the bond
attractor as we consider our moves here.

[57:

Wed Feb 27 07:35:19 2019 So we can build a 1D HC chain using history.
The seed creates a "5'" HC end (though we won't call it that) and
subsequent HC creations (always performed by an existing HC) add on at
the "3'" end.  But, just like in the 2D printer, that creates a tree,
not a chain, unless we limit the 3' creations to just the loose end.
And if we do make that limit, we can paint our chain into a corner.

So is there anything helpful to do with a very straggly tree?  We
could treat it as a chain in the upward direction..

Well at least it avoids leader elections.  If we imbue the root of the
tree with decision authority and have some Plan B mechanism if the
root gets killed.

Well, let's put a parent pointer in HC and grow it just for fun, for
starters.  We'll take three bits for it, say

         2

      1  0  4

         3

with 5..7 available for special cases.

[58:

Wed Feb 27 07:54:06 2019 And what I was going to note a moment ago was
that if we only melt HC -> SC at corners, we can splice such an HC out
of the tree just within the event window.  Only the two adjacent
orthogonal HCs could possibly be depending on the corner HC.. wait
wait wait let's get our distance 2s and distance 4s sorted out here..

       .
      ...
     5.2.7
    .......
   ..1.0.4..
    .......
     6.3.8
      ...
       .

(Note we can turn those parent pointers into coords via
2*ew.getCoord((SiteNum) parentPointer) !)

So, yeah, that's nine possibilities taking four bits, if we're going
to have much flexibility.  With this scheme, as I was saying, we can
always melt a corner without breaking the tree, because if any of our
possible neighbors was pointing at us we can retarget them to our
parent and they can see that.

     q2.7
     q...
     q0.4
     qqqq

Given we're melting 0, its parent must have been 2,7, or 4, and its
only possible kids are 2, 7, and 4 as well.

Buut note our current melting rule doesn't extend that far:

  q__    ..@
  q@_ -> ._.
  qqq    ...

and with just that rule, we could be in a situation like:


    5.2.7
    qq...
     q0.4
     qqqq

but 4 and 5 cannot see each other so the tree could be broken if 0
melted.

But the bigger event window isn't recursive -- after we knock off the
corner we're stuck.

Could we have the HCs background swapping with each other trying to
make the tree a list?  Or trying to make the tree use only orthogonal
links?  If a diagonal link is a 'long bond' and an orthogonal link is
a 'short bond', we could melt any corner that has only short bonds..
[59:

Wed Feb 27 08:25:30 2019 So is there a nice little algebra of bond
shortening?  We're talking swapping entire HCs, I think, so that we
don't (in these operations anyway) change the tree structure, we're
just trying to 'relax' it so that it uses all othogonal bonds.  Now,
our growth rule IS only to orthogonal sites, so the grid will
initially be totally relaxed.

Sample relaxed tree:

     h<h h
     v v v
     h h h
     c ^ v
     h h<h


Melt NW corner:

     |-h h
     v v v
     h h h
     c ^ v
     h h<h

Now it's got one long bond. ..And I don't see any local way to relax that..
[60:

Wed Feb 27 09:05:35 2019 Are there any kind of moves we can make
locally?  It seems only in very restricted cases. [61:

Wed Feb 27 09:06:26 2019 What if, just for a minute, we consider
(effectively) ditching SC and doing something like a SwapLine to move
the HC?  If the HC could use the inter-HC gap for positioning and
movement slack, the HC can be the 'jelly' all by itself.[62:

Wed Feb 27 09:39:24 2019 After morning moment..  So for starters we
could leave the construction stuff rigid, as is.  Need to change the
misaligned maintenance stuff.  Suppose we had a five-state var saying
which way I've gone out of alignment..  Suppose we left behind some
ephemeral thing saying this is where I was?  Suppose we used a literal
SwapLine that anchors against IM?  Boils away if it loses contact with
IM or SL.  Boils away if there's IM in the heading direction.  Grows
in the orthogonal direction as long as there's adjacent IM.

And just suspends HC maintenance when it's around?

Let's try it.

:62]


:61]

:60]
:59]

:58]


:57]

:56]

:55]


:54]
[63:

Wed Feb 27 17:03:15 2019 Hmm seems like maybe a 'legitimate bug' here
in the splattr codegen, regarding beginSiteEval().  Right now it
appears that a SPLATRuleSet calls beginSiteEval() on each of its
directly-used SPLATKeyStates.  But the generated subclasses of
SPLATKeyState don't override beginSiteEval, so we go only to
SPLATKeyState.beginSiteEval(), and any keystates that are only
INDIRECTLY used don't get reset.

What we need is perhaps a single tree-walking beginSiteEval, or better
to have splattr codegen walk the tree and generate a custom
beginSiteEval for each subclass of SPLATKeyState, like it is already
doing for given and vote?  But however it's fixed, I think that's the
reason my

   mm    ..
   @x -> x@
   nn    ..

rule isn't firing..

:63]
[64:

Thu Feb 28 09:41:50 2019 Well, I did ultimately lose on trying to use
let m = s|a for the swapline advance rule, and ended up not only
expressing it in ulam, but then copy-pasting the ulam for keycode n.

So that was bad.  I suspect the issue was the code treats | in effect
as || -- like it skips the 'given a' if the 'given s' part works at a
site.  And somehow that matters, but the logic is so twisted and
unclear -- especially the caching code -- that I can't keep it
straight what the issues and arguments really are.

But there's really no time to try to fix that now.  We have to get to
movable cells and then cleanly reproducing cells PRONTO.

:64]
[65:

Thu Feb 28 09:47:22 2019 So at present we have a west SwapLine largely
working.  We have blocked SwapLine eventually randomly decaying and
that's causing troules because the line needs to be blocked in certain
cases, so we should get rid of that..[66:

Thu Feb 28 09:51:54 2019 Also, still need to get the HC to not detect
misalignment if SL are around..  and not even to try to grow at that
point.. [67:

Thu Feb 28 09:54:10 2019 About the nicest (at least living computation
/ programming-y) thing we've got so far is the idea of using virtual
functions in other elements to perform decision-making-on-the-fly
rather than pulling additional state forward into the forward actor.

We could think about extending that to more cases -- such as how many
'crowding votes' a given piece of content should have.  With such a
mechanism in hand we could have SwapLine count for extra crowding so
the membrane would tend to back off and give SL room to work.  The
current common blocking case is like:

     OI                     OOO
     OIH          or        OII
     OIS                    OIH
     OI S                   OIS

where the upper S can't extend the swapline upwards until there's room
behind the H to swap it backwards.  If S could say 'Give me space'
that would help.

[68:

Thu Feb 28 09:56:53 2019 Possible title angles:

Digital cell mechanics --
Extreme stigmergy via virtual functions

:68]

:67]

:66]

:65]
[69:

Thu Feb 28 10:09:26 2019 Wellll, fudge.  So we're actually pretty
fogged on the swapline-inside-membrane idea.  Because the cuteness of
the swapline is that it has a simple spatial invariant -- as long as
there's SL or IM in either x+-1 of each y+-1, the SL is consistent.

But maintaining that invariant requires that the IM NOT MOVE WHEN AN
SL IS RELYING ON IT.  So it's not enough that we were thinking the SL
might ask the IM to back off and make room -- we'd ALSO have to be
able to tell the IM not to move because we're counting on it as an
invariant.

So I think probably we should consider the swapline dead for this
application, for the moment.

Let's go back to thinking about the command & control from the
approximate center of the cell.  Like:

 - Once the cell is big enough, a cell near the center -- with its
   W,E distances all about equal, and also its N,S distances -- may
   declare itself the 'LEADER'.

 - If an HC detects an adjacent (4 ngb) LEADER, it becomes a
   'FOLLOWER'

 - If a LEADER detects an adjacent LEADER, their 'centerednesses'
   estimates are compared and the 'more centered' LEADER wins, with
   ties going to @.  The loser is demoted to a newly-created FOLLOWER.

[71: Thu Feb 28 11:18:02 2019 But maybe not this one?  The point of
building a 'quieter' execution environment is to support relatively
stable spatial structures, to use for computations involving more
state than can fit in a single atom.  The LEADER presumably wants to
use state in the FOLLOWERs, but if the LEADER flops around willy-nilly
that will be hard to do.  I think we should allow the leader to drift
off center at least somewhat.  :71]
 - If the LEADER detects that a FOLLOWER is _more_ centered than the
   LEADER, the LEADER swaps nearly completely with the FOLLOWER --
   except it does not swap the WNSE info.

[70:

Thu Feb 28 11:16:21 2019 The leader[72:

Thu Feb 28 11:21:45 2019 What if we say the followers are used to make
a redundant state vector.  Well what state do we expect the leader
will want to save?

LEADER tasks:

 - Issuing movement orders

 - Waiting for order completion or timeout

 - Holding the 'current mode'?

 - Performing mode switching?

[73:

Thu Feb 28 11:27:36 2019 So surely one story is the LEADER is the CPU
and program counter, and the FOLLOWER shared state is the program and
data.

So the WNSE distance gradients are an example of sensory data.  Those
are so important they're 'built into' the HC.  But we could have a
variety of other 'sense carriers' that head upgradient via the interHC
gaps and serve to ...wait

Suppose the FOLLOWERs represent a MODEL of the entire cell.

Each (perhaps 8ngb) FOLLOWER is in effect responsible for representing
(and eventually controlling) a quadrant (octant) of the cell.

The POINT is to make AN EVENT WINDOW-SIZED MODEL of something that's
MUCH BIGGER THAN AN EVENT WINDOW.  So we can weigh information from
far-flung corners of the cell and make an informed decision in a
single event.  (Albeit with necessarily somewhat stale information.)

[74:

Thu Feb 28 11:34:39 2019 So suppose a SenseCarrier works like this.
It has a sense coordinate that is set to 0 when it's created, and is
updated as the SC moves.  The SC does a stochastic hillclimb toward
the center, and when it comes within range of the (a?) FOLLOWER
responsible for that coordinate, the FOLLOWER integrates that data and
consumes the SC.

Doing 8 ngb followers could give us a better range of action, in the
sense that we could move in 8 dirs based on the 8ngb max freespace,
for example.  Although we could use ties or weighted choosing over
4ngb to achieve similar effects, I suppose.

So how could we get this cell to head towards free space?  We want to
be sensing outside the membrane for that.

Well, OM could record the outside density it sees, and perhaps do a
little low-pass smoothing on that.  Every so often IM could generate
and release an SC based on an adjacent OM density estimate.

Or could OM do edge detection?  Track apparent changes in density and
release SC preferentially or more frequently on changes?[75:

Thu Feb 28 11:47:27 2019 OK, well about to have to head off to the
shower and then busy busy in the world for a good chunk of the
afternoon, but can we first get down to some

TODO:

[78: Fri Mar  1 03:11:25 2019
DONE :78] - Add an Unsigned(2) mRole to HC.  0 == visitor, 1 == employee, 2 ==
   vice president, 3 == president.

[79: Fri Mar  1 03:11:33 2019
DONE :79] - Get a centrally-located HC to declare itself P once the X and Y
   diameters reach say 5 and there's no other P around

 - Have 8ngb P's highlander it out as discussed

 - Have HC who see a 4ngb P declare itself VP

[maybe
 - Otherwise have HC who see a 4ngb VP declare itself employee

 - Otherwise have HC who see a 4ngb employee maybe declare themselves
   employee.  Like 50-50?

 - Otherwise have HC declare itself visitor
 ]

[80: Fri Mar  1 03:11:44 2019
DONE :80] - Have getColor identify the 'C-suite' occupants

 - Have OM measure and store exterior density excluding Res.  Store it
   in five bits?  Have the density denominator be not the event window
   size but only the stuff outside the OM?  Can we do that?

 - Have IM average the exterior density of its local OM.  Store it in
   five bits too?

 - Have IM release a sense-density thing every so often

 - Create a Reporter class that climbs the corporate ladder and gets
   eaten by VPs.

:75]

:74]

:73]

:72]

:70]

:69]
[76:

Thu Feb 28 12:11:51 2019 Have to start packing up.  See yall on the
other side.

:76]
[77:

Fri Mar  1 00:14:46 2019 OK here we are.  Jeez now it's March.

:77]
[81:

Fri Mar  1 03:42:32 2019 So, we're kind of growing a 'nucleus' thing
now, although it doesn't do anything except exist.  What I'm realizing
is we are going to have an extra-cellular environment that's just
plastered full of Res, and that that's a hint.

We should have cellular operations routinely _consume_ Res.  Res
should not just be for transmuting into HC, it should power
everything, and the cell should not stop importing it just because
it's reached a mature size.

So I think QCyt or HC should have an mEnergy variable, that it runs
down by doing things, and charges up by consuming Res.  Or if we're
really disruptive, by transmuting Res into Ser or Waste or whatever we
want to call it.  The Ser would routinely be ejected from the cell,
where it would then gradually get converted into Res by the action of
DReg.

HC should send Ser downgradiant.  We'd like Ser to do that itself but
it seems kind of non-physical?  Maybe not.

Let's commit this nucleus stuff and then try some kind of waste
metabolism demo.

[82:

Fri Mar  1 03:48:53 2019 Although, looking at the movie I'm making
here, we are facing another leader conflict example.  Not sure how it
came to happen but it makes me want to be able to distinguish between
VPs that are looking to a leader and those that are just wondering if
they'll win the leader race.  Once someone is looking to a leader
everybody nearby needs to FOGGEN GET ON BOARD.

:82]

:81]
[83:

Fri Mar  1 04:34:04 2019 Leaving the previous movie accumulating.
Have some untested cuts at a 'mServing' data member in
HardCyt.. whups, the movie cell just exploded somehow.  Guess we
should kill that run and generate the movie..[84:

Fri Mar  1 04:44:57 2019 Well not clear.  DReg opened the membrane
long enough for QCyt to see OM is the guess.[85:

Fri Mar  1 13:23:24 2019 OK made an mServing hack but in the lunch run
never got a core developing.  [86:

Fri Mar  1 13:39:54 2019 OK this run got a core which is looking
pretty stable so far..

:86]

:85]

:84]

:83]
[87:

Fri Mar  1 14:21:07 2019 Well basically I think we have to try the
Res-metabolism story, even though of course we totally don't have
anything like the time to undertake such a massive rethink.

So we're going to commit this current snapshot (with barely-tested
mServing and all) and then try it.

:87]
[88:

Fri Mar  1 14:32:15 2019 OK, committed.  Res metabolism

TODO:

DONE - Decide if we're closing the loop 'materially' or only
   'energetically'.  In the latter case we don't need a 'Turd'
   particle.  We just consume the Res and let empty space represent
   lack of free energy.

   Well it seems the whole DReg concept pushes for 'energetic'
   closure, since it doesn't make any distinction between types of
   material (other than DReg itself).

   Let's at least start with energetic closure.

[89: Sat Mar  2 01:02:50 2019
DONE :89] - Make an Unary(2) mEnergy for QCyt.  Have a high-level rule that
   consumes Res with mEnergy < mEnergy.maxof.

[90: Sat Mar  2 01:02:58 2019
DONE:90] - Brighten QCyt getColor in proportion to mEnergy

[91: Sat Mar  2 01:03:13 2019
DONE:91] - Start making rules require mEnergy > 0 and start decrementin
   mEnergy when they fire.

:88]
[92:

Sat Mar  2 01:03:18 2019 So before nap we got to the idea of moving
the cell by having the leader move, and design the rest of the cell to
fall towards having the leader in the middle of the cell.

Right now, the 'mRole' provides a small amount of gradient around the
leader.  If we said something like "serving HC don't melt" that would
create a weak bias towards keeping the leader in the middle.

:92]

[93:

Sat Mar  2 04:25:57 2019 OK, so trying to drag the cell by moving the
leader, and preventing the c-suite from melting, is, at best, very
slow.  Kind of like the non-accelerated chain in the original 'large
object motion' video (Asymmetric diffusion of bonded structures in the
Movable Feast Machine, October 2011).

And, worse, once the core had gotten far enough off center, and the
cell gotten big enough, a second leader and emerged.  We're not ready
to deal with that.

So, if we ditch mRole as an explicit data member, and go to a second
x,y pairing for location relative to the leader, we can avoid the
second leader problem and likely accelerate movement significantly.

It 'just' means burning another non-trivial chunk of HC bits for a
second coordinate system.  Like 2xInt(5) perhaps?  2xInt(4) possibly?
And we soften/don't harden when we appear maxed on a coordinate?
Perhaps reserve Int(4).minof as an initial value and a code meaning
'no leader seen'?

What do these gradients relax to in absence of a leader to anchor
them?  I guess if a guy thinks he's distance one but doesn't see the
leader, he punts to 'no signal', and that just propagates?  How does
it propagate?  What does seeing 2 + 3 + nosignal, say, result in?

Answer: A nap.
[94:

Sat Mar  2 13:45:40 2019 OK so back from morning errands, including
picking up and trying out the M3x28mm socket cap screws for the case
corners.  They're a hair short, in principle 29mm might be better, but
30mm would be way long so..  They catch okay in the M3 nuts; as long
as they catch a few turns in the brass standoffs it'll be fine.

Anyway.[95:

Sat Mar  2 16:30:00 2019 So we will follow the mRole style and just
have a single Z value, instead of another set of X + Y values.  The
leader is the king of the hill and everybody else does max-1 on their
neighbors.  We'll do merely an Unsigned(3), say, for Z value, because
that still gives us a radius of 14 HC, which is about right for our
cells.

I'm wondering about having (at least) melted SC maintain enough state
that they can make a visit toward the center, and, after they get
close enough, then head for the nearest membrane wall.  A little
Unary(2) could be enough for that, or Unsigned(2) if we wanted a
little room to grow.

TODO:

[96: Sat Mar  2 16:43:22 2019 Well, first

DONE - Commit the Res metabolism stuff, then.. :96]

 - IMPLEMENT ALL THAT NOW NOW NOW

:95]

:94]

:93]
[97:

Sat Mar  2 16:51:04 2019 Well, it _seems_, just growing
HC.ulam:cROLE_BITS from 2u to 3u will do a fair chunk of the 'Z
gradient' redo.  Current question is whether the 'Bool mServing' is
really doing anything but confusing us?

:97]
[98:

Mon Mar  4 06:48:14 2019 Well the cell in the overnight run survived
past 600kAEPS, but didn't make a whole lot of progress heading east.
It developed a tile-spanning vertical front that looked hard to break
out of.  Suspicion is that this code

    u Bool inFreezingRange() {
    .   return getOutDistanceEstimate() <= Role.maxof/2u;
    . }

in HardCyt.splat is implicated -- with Role.maxof/2u == 7 and the HCs
spaced at period two, that's ~15 HCs taking ~30 sites, plus ~4 for the
membranes.  So we think we want to change it to:

    u Bool inFreezingRange() {
    .   return getOutDistanceEstimate() <= cCORPORATE_DIAMETER;
    . }

but wanted to commit the code associated with the run first.


:98]
[99:

Mon Mar  4 12:44:51 2019 OK, commit ahead of moving the flag.  Making
some progress but still not moving very far.

:99]
[100:

Mon Mar  4 13:48:38 2019 Back.  Starting up a run on the 'big machine'.

:100]
[101:

Tue Mar  5 15:10:16 2019 OK, post T2sday Update #221, and we have the
one week extension to Friday March 15.

So that means there are two immediate things

TODO:

(1) We really need to frame up the paper now:
    - Clear out last year's gunk
[104: Tue Mar  5 16:21:38 2019
DONE :104]    - Make up some phony section heading
[105: Tue Mar  5 16:21:46 2019
DONE :105]    - Spitball some titles and abstract/intro sentences

(2) We can take a run at getting these cells to move better, in the
    DReg/Res soup, by

    - having the core modulate cell aspect ratio based on direction,
      rather than just fixed distances
    - making the cilia smart enough to 'flow' the soup around the
      cell, rather than just pushing it away.

:101][102:

Tue Mar  5 15:15:01 2019 Titlestorm:

Movable protocell computation in a corrosive environment
Metabolism and mobility: A digital protocell in the Movable Feast Machine
A Movable Feast: Mobility and metabolism in a dangerous environment
A Movable Feast: Mobility and metabolism in a corrosive digital environment
A Movable Feast: Mobility and metabolism in a digital environment
A Movable Feast: Robust mobility and metabolism in a digital protocell

:102][103:

Tue Mar  5 15:35:14 2019 Abstrabstracts

Hearing yourself think.
A 'quiet' computational environment
Computation benefits from a quiet

Reality is a blooming and buzzing confusion.
Computations make decisions based on inputs, and to do that job
reliably, the 'internal noise' of the computational machinery needs to
be managed effectively.
[119:

Wed Mar  6 02:38:50 2019 The interior of a cell, and its immediate
environment, forms a distributed computation rich with a complexity of
tasks and rife with implementation opportunities.[142:

Wed Mar  6 16:06:18 2019 Traditional computation has revolutionized
society many times over, but now it is increasingly unscalable and,
already, dangerously unsecurable.. etc etc..  In keeping with the
theme of this conference "How can Artificial Life help to solve
Societal Challenges?"

:142]

:119]
:103]
[106:

Tue Mar  5 16:22:06 2019 So, how are we going to program Cilium?  For
flow, could we say like clockwise or counterclockwise relative to OM?
So 'pushing direction' could be IN, OUT, CLOCKWISE, ANTICLOCKWISE,
NONE, or something like that?
[107:

Tue Mar  5 17:03:57 2019 (Just started a 'Doctor it hurts when I do
this' 3-up T2 case print job.  We shall see.)

:107]
:106]
[108:

Tue Mar  5 17:06:32 2019 Aaaand how would we implement this clockwise
and anticlockwise business?  Two parts to it:

 - How does OM decide what is desirable based on the local QC?

 - How does Cilium decide which way to push?

[109:

Tue Mar  5 17:08:56 2019 Now that second point seems easier, or at
least more local: You'd think, if you just keep the OM, say, below
you, then CW is east and CCW is west.  But we'd have to allow only the
rotational symmetries for that to work.

We kind of liked the getWestIndex/getNorthIndex approach that now
lives in QCyt.  Could we use that to produce reasonably transparent
code to answer the question: Given symmetries and my programming, is
west (in rule space) a good direction to push stuff?
[110:

Tue Mar  5 17:19:50 2019 Seems like we'd just like to call
isFlipped().  If we're not flipped, OM below -> W is CCW, and if we
are flipped, OM below -> W is CW.  So if isFlipped() == (dir == CW),
then west is a good direction to push stuff, no?  [111:

Tue Mar  5 17:24:30 2019 Well if that's transparent I must be blind..
I guess I have to do cases..


         1           1-4 : Locations of Cilium

       OOOOO           * : Core/heading direction
      OaaaaaO
   3  O    *O  4       a : HC announcing anticlockwise
      OcccccO          c : HC announcing clockwise
       OOOOO

         2


So, * decides on -- let us say -- an orthogonal direction DIR.  Now,
as in src/core, Dirs.h, we can get the CWDir with (DIR+1)%DIR_COUNT
and the CCWDir with (DIR+DIR_COUNT-1)%DIR_COUNT

And we can get the offsets associated with those directions as in (the
original minimal) FillDir(SPoint &, Dir).  [112:

Tue Mar  5 18:09:23 2019 Hmm.  That whole development was leading to
saying HC on _this_ side of CORE say FOO and on _that_ side say
BAR.. ..but we don't know which side of CORE we're on.  That was the
big 'clever' trick -- that we only needed a 'leader Z' (implemented as
mRole) -- and not an X and Y.

So I guess CORE just announces the direction of travel -- perhaps even
2xUnsigned(3) for speed and direction -- and all the HC copy it.  We
don't need UMod or count to infinity because we just trust
management.  So each HC knows the dir, and each HC knows its own
position in the cell, so it can figure out what to present to OM.
Somehow..
[113:

Wed Mar  6 00:09:30 2019 And SC can head in the given dir.  It's like
it's too easy if everybody knows the direction.  "It's a trap!" says
Admiral Ackbar.  And, well, we're just going to have to be Bond James
Bond about that.

So let's figure out a way to be clean about all this, and then get
right on that.

Things to modulate based on heading:

 - Cilium push behavior

 - Desired cell aspect ratio

 - Desired absolute cell dimensions

 - HC -> SC and SC -> HC conditions

So, we really want to be able to express things -- at least things
like the aspect ratio -- in terms of the heading direction.  Because
like all diagonal heading directions would end up wanting the same,
square, aspect ratio..

Or just own it: Only do the orthgonal directions, using say
2xUnsigned(2).  Only four bits cheap cheap!

The speed could go directly to the 'orthogonal narrowing'.  At speed
zero we want our desired radius to be equal in X and Y -- producing
square aspect ratio.  At speed one, we want the heading radius to be
+1 and the orthogonal radius to be -1 relative to the square case.  At
speed N, aspect ratio is (BASE+N,BASE-N) in (heading axis,orthogonal
axis) units.

Now, that doesn't produce constant area.[114:

Wed Mar  6 01:26:33 2019 In fact the area declines by 4*N**2 regardless
of BASE (treating BASE as a diameter, not a radius though).  So maybe
that's tolerable -- maybe we're thinking you probably ought to have
N**2 SC in flight while you're moving at speed N anyway.

But if BASE is a diameter, how do we allocate BASE-1 above and below
the 0?  But, wait, there is no zero here, there's just our four
distances which implies a width and a height and our position within
that.

(Do not try to split the zero, that's impossible.  Instead, only try
to realize the truth: There is no zero.)

[115:

Wed Mar  6 01:41:34 2019 So, I'm imagining BASE==8 is where we want to
be, with a nice plump resting area of 8*8 == 64, narrowing to 11*5 ==
55 at max speed == 3.[116:

Wed Mar  6 01:54:14 2019 Now, before we get much further, I want to
revisit the '1u +'s in getWidthEstimate and getHeightEstimate.

Do we really not count ourselves when we're doing
updateDistanceEstimates?  How does that actually work?[117:

Wed Mar  6 02:05:13 2019 Well, we look at the HC west of us in rule
space.  In the default (000L) symmetry, we set our west distance to be
one more than theirs and set our north distance to equal theirs.
Unless we see QMembrane there instead in which case we set our west
distance to 0.
                 ANCHOR INFORMATION      DERIVED INFORMATION
                     w   n   s   e           w   n   s   e    w+e  s+n
                 a   0   0               a   0   0   1   2     2    1
     a  b  c     b       0               b   1   0   1   1     2    1
                 c       0       0       c   2   0   1   0     2    1
     d  e  f     d   0       0           d   0   1   0   2     2    1
                 e           0           e   1   1   0   1     2    1
                 f           0   0       f   2   1   0   0     2    1

and so okay, 1u+ indeed, w+e+1 == 3 for everybody and n+s+1 == 2 for
everbody, as it should be.

:117]

:116]

:115]

:114]

:113]
:112]


:111]

:110]

:109]

:108]
[118:

Wed Mar  6 02:15:14 2019 So okay.  Everybody knows the(ir estimate of
the) current cell size.  We will distribute speed and direction.  With
some manipulation to be named later, an HC determines if it's in or
out of the currently desired aspect ratio.  ..And that's where 'the
zero', or something like it, comes right back in.  Presumably we were
imagining that aspect changes would be roughly balanced around the
center of the cell, rather than all happening at whatever are
nominally called the 'large' ends of the x and y axes.

So we cut half the rows from the small and and half the rows from the
large end of the axis.. and just accept that the extra row will come
from the large end?  That's kind of ucky.  Could we go stochasto if
there's an odd row, and let HC at both extremes melt 50% of the
chances?  That will tend to favor melting both sides, since the
bounding box tends to go to the max..?  But wait -- as the box becomes
non-rectangular due to irregular melting, the distance estimates will
start to become unstable as well, so that later HC decisions will be
more likely to see distances saying that there is no need to cut
another row..

So maybe odd-row stochasto is the way to go?  We're going to be
somewhat stochasto even on full row eliminations, because that's just
what we do, so maybe we can avoid a special case.

[120:

Wed Mar  6 03:34:03 2019 So are we getting at all close to
implementation opportunities here?

TODO:

[121: Wed Mar  6 04:17:36 2019 First cut
DONE :121] - Make QHeading.splat (.ulam?) for speed and dir and to hide dir
   mapping crap

[122: Wed Mar  6 04:17:43 2019 ditto
DONE :122] - Make QVision.ulam for stuff to be shared down the hierarchy.
   Perhaps have it contain a tagged union?  So movement is just one
   possible vision.

[123: Wed Mar  6 04:17:50 2019 ditto
DONE:123] - Put a QHeading in the QVision union and add a tag for it

[124: Wed Mar  6 04:17:57 2019 ditto
DONE :124] - Put a QVision in HC.

[138: Wed Mar  6 16:00:29 2019
DONE :138] - Share the vision following the role hierarchy

[139: Wed Mar  6 16:00:36 2019 Well, technically,
DONE :139] - Have the leader rarely change the vision to movement with random
   direction and speed.

[140: Wed Mar  6 16:01:16 2019 What happens is the new vision
propagates _very_ rapidly, and then nothing else happens.  But:
DONE :140] - See what happens.

:120]

:118]
[125:

Wed Mar  6 04:18:08 2019 So with this motion scheme do we still move
the core or not?  Well, I guess we have to, otherwise eventually it'll
fall out of the aspect ratio and need to melt.  And we cannot have the
leader melt.

So the leader moves mainly to keep itself safely in the core of the
matrix.  And maybe it doesn't lead by doing anymore, since it's
announcing its visions to all.  So does it just try to stay in the
middle of everything, and screw being at the leading edge?  If so,
maybe we just accept a swap if the westIndex distance is greater than
the opposite.  (How do we get the 'opposite index'?  3u-idx I guess.)

:125]
[126:

Wed Mar  6 04:41:46 2019 What about a modifier on SPLAT 'vote' that
means do a max over the site voting, instead of proportional?  I've
wanted that many times, and it seems reasonably both clear and
doable.  We could say that a 0u vote continues to be a veto for that
site, but all votes > 0u are compared for max and only sites that end
up with the ultimately max value are eligible to win.  And we pick
uniformly among ties for max.  And it would probably take at most one
bit in the implementation.. well, maybe not.  Let's take a look.[127:

Wed Mar  6 04:54:12 2019 So yeah, need a few more bits.  Maybe 1+6==7
bits per keystate, worst case, I guess.  In SPLATKeyState.vote_
(SPLATInstance.ulam:339), we'd replace like this

    m_numberVotes += (Unsigned) m_voteValue;
    Random r;
    if (r.oddsOf(m_voteValue, m_numberVotes)) {
      m_winnerSN = cursn;          // for now..
      m_winnerAtom = curatom;      // in the clubhouse..
    }

with something like this:

    Random r;
    if (!m_maxVote) {
      m_numberVotes += (Unsigned) m_voteValue;
      if (r.oddsOf(m_voteValue, m_numberVotes)) {
        m_winnerSN = cursn;          // for now..
        m_winnerAtom = curatom;      // in the clubhouse..
      }
    } else {  // max voting
      if ((Unsigned) m_voteValue > m_numberVotes) {
        m_numberVotes = (Unsigned) m_voteValue;
        m_winnerSN = cursn;          // for now..
        m_winnerAtom = curatom;      // in the clubhouse..
        m_ties = 0u;
      } else if ((Unsigned) m_voteValue == m_numberVotes &&
                 random.oneIn(++m_ties)) {
        m_winnerSN = cursn;          // for now..
        m_winnerAtom = curatom;      // in the clubhouse..
      }
    }

and we need an extra Bool m_maxVote and an Unsigned(6) m_ties.
Although m_ties maxes at 41, if all sites are the same keycode and all
tie, so we could use like Unsigned(6).maxof to mean 'not max voting'
and get away with 6 bits total.

Then we'd need a way to get the (moral equivalent of) m_maxVote set
and cleared for the keycodes that do or don't want it, and a syntax to
express it in SPLAT.

I guess a 'virtual Bool useMaxVoting() ;' would do it, since we do
have a subclass for each mentioned keycode.  I think.

And, 'vote (max)? keycode ..' seems obvious enough, trading on the
single char restriction on keycodes.

[128:

Wed Mar  6 05:13:43 2019 OK well it's totally inevitable that I'm
going to try implementing this.

Here we go.

:128]

:127]

:126]
[129:

Wed Mar  6 05:33:53 2019 Aaand those measly six bits for m_maxVoteTies
gets us what?  Of course, this:

    /data/ackley/PART4/code/D/ULAM/bin/../share/ulam/stdlib/ByteStream.ulam:119:1: ERROR: Trying to exceed allotted bit size (8192) for transient SPLATRuleSet_13QMembrane with 8292 bits.
    ./.splatgen/QMembrane.ulam:1051:11: NOTE: Components of SPLATRuleSet_13QMembrane are..
    /data/ackley/PART4/code/D/SPLAT/blib/script/../lib/auto/share/dist/App-Splattr/SPLATInstance.ulam:469:11: NOTE: (2340 of 8292 bits, at 0) from superclass: SPLATRuleSet.
    ./.splatgen/QMembrane.ulam:1052:3: NOTE: (0 of 8292 bits, at 2340) 0Hzy key_Dot.
    ./.splatgen/QMembrane.ulam:1053:3: NOTE: (0 of 8292 bits, at 2340) 0Hzy key_At.
    ./.splatgen/QMembrane.ulam:1054:3: NOTE: (0 of 8292 bits, at 2340) 0Hzy key_Underline.
    ./.splatgen/QMembrane.ulam:1055:3: NOTE: (0 of 8292 bits, at 2340) 0Hzy key_a.
    ./.splatgen/QMembrane.ulam:1056:3: NOTE: (0 of 8292 bits, at 2340) 0Hzy key_b.
    ./.splatgen/QMembrane.ulam:1057:3: NOTE: (0 of 8292 bits, at 2340) 0Hzy key_c.
    ./.splatgen/QMembrane.ulam:1058:3: NOTE: (0 of 8292 bits, at 2340) 0Hzy key_d.
    ./.splatgen/QMembrane.ulam:1059:3: NOTE: (0 of 8292 bits, at 2340) 0Hzy key_e.
    ./.splatgen/QMembrane.ulam:1060:3: NOTE: (0 of 8292 bits, at 2340) 0Hzy key_f.
    ./.splatgen/QMembrane.ulam:1061:3: NOTE: (0 of 8292 bits, at 2340) 0Hzy key_i.
    ./.splatgen/QMembrane.ulam:1062:3: NOTE: (0 of 8292 bits, at 2340) 0Hzy key_n.
    ./.splatgen/QMembrane.ulam:1063:3: NOTE: (0 of 8292 bits, at 2340) 0Hzy key_o.
    ./.splatgen/QMembrane.ulam:1064:3: NOTE: (0 of 8292 bits, at 2340) 0Hzy key_q.
    ./.splatgen/QMembrane.ulam:1065:3: NOTE: (0 of 8292 bits, at 2340) 0Hzy key_r.
    ./.splatgen/QMembrane.ulam:1066:3: NOTE: (0 of 8292 bits, at 2340) 0Hzy key_x.
    ./.splatgen/QMembrane.ulam:1067:3: NOTE: (0 of 8292 bits, at 2340) 0Hzy key_z.
    ./.splatgen/QMembrane.ulam:1051:11: ERROR: CLASS (regular) 'SPLATRuleSet_13QMembrane' SIZED 8292 FAILED.
    Unrecoverable Program Type Label FAILURE.

Not sure why everything's hazy considering culam seems to know the
total, but we get the idea..  We are now precisely 100 bits over --
although we're not sure how far under we were before..

Bugger.[130:

Wed Mar  6 05:43:39 2019 Could we put the tie storage in the
subclasses that actually use max voting?  Of which there are none at
present?  And just have another virtual function or two protruding up
into SPLATKeyState, costing us zero bits?

Probably.  But need a nap now.

:130]


:129]
[131:

Wed Mar  6 10:01:48 2019 OK had a nap.  If we're adding virtual
function calls to voting do we want to be specific about max voting at
all, or just dish to a 'mergeVotes' routine that can do what it wishes
and then returns the number of votes for the site (or etc)?

Seems like you could, for example, make a case for min voting -- the
smallest non-zero score -- and who knows what else.
[132:

Wed Mar  6 10:37:17 2019 OK so now we have SPLATKeyState defining
'virtual Bool mergeSiteVote(SPLATRuleSet & rs)' to do proportional
voting, and SPLATKeyStateMAX : SPLATKeyState overriding that to do
proportional voting.[134: Wed Mar  6 12:08:36 2019 Redoing this to
have 'Bool mergeSiteVoteMax(SPLATRuleSet & rs, EventWindow.SiteNum &
ties)' in SPLATKeyState, for 'max-y subclasses' to call and provide
with storage.. :134]

And we're no longer blowing out our transient bit budget -- but then,
nobody is using max voting yet.  So, is the syntax indeed:

    vote max k [WHATEVER]

vs

    vote k [WHATEVER]

?


:132]
:131]
[133:

Wed Mar  6 11:58:27 2019 Urgh, tracing through where we need codegen
changes for 'vote max', the grossest issue so far is the special key
codes, which already have their own keystate subclasses:

        my %baseClassForSpecialKeyCodes = (
            "_" => "SPLATKeyStateEmpty",
            "@" => "SPLATKeyStateSelf",
    #        "=" => "SPLATKeyStateSelfType",
            "." => "SPLATKeyStateAny",
            "?" => "SPLATKeyStateOccupied",
            );

and would/will now to have that cross-producted with max voting.
'SPLATKeyStateEmptyMax', and so forth.

Urgh.  And how do we avoid duplicating guts in SPLATKeyStateEmpty vs
SPLATKeyStateEmptyMax?  Try to make it a template with a base class
template argument?  No, we don't have type arguments to templates.

By making SPLATKeyStateEmptyMax be a subclass of SPLATKeyStateEmpty,
and just adding on the voting override.  I guess we can just define
all the Max subclasses in SPLATInstance, pay every time for culam to
look at them, and hope they won't get loaded if nobody uses them.

:133][135:

Wed Mar  6 12:37:34 2019 Well, we've extend the stored override info
to include a fifth array element:

        $ks->{overrides}->{$VERB} = [$delim, $OPTISA, $EQUALS_BODY,$self->{sourceLine},$voteMax];

where $voteMax is undef in the proportional case and 1 if 'vote max'
was seen.  (At present the max modifier can be used only when
$VERB=='vote').  Now it's up to (the appropriate) everybody to look at
that (at appropriate times).

:135]
[136:

Wed Mar  6 13:54:17 2019 OK so max voting appears to be working.  It
looks reasonably nifty, too:

    vote max h isa HardCyt { return $self.mServing ? $self.mRole : 0u; }

then

    check @ {
    .  HardCyt & hc = (HardCyt&) ew[0];
    .  hc.mRole = (Role) ($h.$nvotes - 1u);    // Saturating at 0u below
    .  hc.mServing = (hc.mRole > 0u);          // No role, not serving
    .  return false;  // Drive-by update
    . }

with $h.$nvotes becoming the max value found or 0u if none.

I wanted to do like

    vote max h isa HardCyt : $self.mServing ? $self.mRole : 0u

or
    vote max h isa HardCyt = $self.mServing ? $self.mRole : 0u

but neither of them work.  The ':' introduces a boolean expression, so
the would-be max values get normalized to 0u/1u.  And the '='
introduces a key expression so the second example doesn't parse at
all.

There's just no sigil in SPLAT to introduce an Unsigned or Int or
general expression.  So be it.

Let's commit this.

:136]
[137:

Wed Mar  6 15:11:29 2019 OK so let's propagate the vision..

:137]
[141:

Wed Mar  6 16:01:58 2019 OK, so the vision is propagating and now we
need the infrastructure for all the aspect ratio and such.

TODO

[153: Thu Mar  7 13:33:53 2019 With some redesign and so far little testing
DONE  :153] - Make C2D QHeading.getTargetShape() to get the cell's target (W,H)
   shape as a function of the heading.[143: Wed Mar  6 17:42:49 2019 I
   think that signature is wrong -- we need to return a Rect, somehow,
   to express the positioning of the target shape within the cell
   bounding box.  We should probably pass in the HC's notion of the
   cell area, and get back a rect expressed relative to that cell
   area.  But that's going to have to wait until after the evening. :143]

[154: Thu Mar  7 13:34:29 2019 Well, sort of
DONE :154] - Make  HardCyt.getSiteStability(C2D targetShape) to determine how
   meltable self is as a function of targetShape and self's
   mDistances, by centering the shape as much as possible and
   prorating fractions to both extremes.

[155: Thu Mar  7 13:58:42 2019 Made 'permilToSoften()'
DONE:155]   = Choose a return type for getSiteStability.  StabilityCode?
     Unsigned(2): very soft, soft, hard, very hard?  Or: Unsigned(5):
     Odds exponent for melting?  melt == oneIn(1u<<ret), from ret==0
     being certainty to ret == 31 being one in four billion?

[156: Thu Mar  7 14:02:51 2019
DONE :156] - Wrap both of them, plus the ensuing random shot, up into Bool
   HardCyt.siteShouldSoften()

[157: Thu Mar  7 14:03:05 2019
DONE :157] - Update the HardCyt.splat:250ff melting rules to use siteShouldSoften

[158: Thu Mar  7 14:03:33 2019 Well, hard to tell what's change, but watched some
DONE :158] - Get it going and watch it

 - Return here to make to-do for SoftCyt being smarter

:141]
[144:

Thu Mar  7 00:23:56 2019 So, how do we decide where to position the
target shape within the bounding box implied by the DistanceArray?
You'd think the speed should maybe have something to do with that?

But I have to think advancing the target shape by 3 cells for a speed
of 3 is way too fast -- like the whole cell would melt.  Or would it?

If we anchored the advanced shape to the leading edge of the movement,
the trailing edge would melt until the bounding box was small enough
to tuck in in the back of the target shape  -- and melting would stop
there until there was an advance on the leading edge.

Well I guess we're going to try it.

How about an example first?

QHeading
  mSpeed == 2
  mDir   == cDIR2_EAST
  getShapeOffset() == (2,-2)

HardCyt H
  mDistances[WNSE] == 0,2,6,9
  boundingBox == (9,8)
  shape == (8,8)
  r[0] = (10,6)
  r[1] = (2,-1)

          0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16

   0      .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .

   1      .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
                    >1 >2 >3 >4 >5 >6 >7 >8 >9
   2      .  .  .  .==.==.==.==.==h==.==.==.==.  .  .  .  .
                 ^2|                         ||
   3      .  .  .  .  h  h//h//h//h//h//h//h//.//.//.  .  .
                 ^1|    //                   ||    //
   4      .  .  .  H  h  h  h  h  h  h  h  h  .  .  .  .  .
                 v1|    //                   ||    //
   5      .  .  .  h  h  h  h  h  h  h  h  h  h  .  .  .  .
                 v2|    //                   ||    //
   6      .  .  .  h  h  h  h  h  h  h  h  h  h  .  .  .  .
                 v3|    //                   ||    //
   7      .  .  .  h  h  h  h  h  h  h  h  .  .  .  .  .  .
                 v4|    //                   ||    //
   8      .  .  .  .  h  h  h  h  h  h  h  .  .  .  .  .  .
                 v5|    //                   ||    //
   9      .  .  .  .  h  h//h//h//h//h//h//.//.//.//.  .  .
                 v6|                         ||
  10      .  .  .  h--h--h--.--.--h--h--h--.--.  .  .  .  .

  11      .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .

  12      .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .


:144]
[145:

Thu Mar  7 01:34:58 2019 So, drawing this example, that +1 in the
mDistances width and height estimates is a pain in the butt.  It makes
things come out right for (x = min; x < max; ++x) style iterations,
but it sure doesn't LOOK like a BOUNDING box..

I guess I could just subtract (1,1) for my purposes.  "As Long As It's
Clear Why."

[146:

Thu Mar  7 02:04:58 2019 Running out of gas again.  How many places
are using the WNSE bounding box, currently?

 - HardCyt.getVolumeEstimate() uses it.  And it needs the +1 to
   include both sides to get the right answer.  So, there.[147:

Thu Mar  7 09:23:00 2019 But getVolumeEstimate could add the (1,1) --
it has a pretty clear fencepost reason to need to.
[148:

Thu Mar  7 09:25:16 2019 The underlying getHeightEstimate (and width)
are used independently in two other places -- both to estimate the
size of the cell.  (1) Is the cell big enough to have a leader?  and
(2) Is the cell so big it should explode?

And in both of those places, I'd think, a +1 or not shouldn't be a
critical difference.  "shouldn't".

Let's switch it over to 'true' bounding box and compensate in
volume.. [149:

Thu Mar  7 10:12:41 2019 Hmm, C2D.contains() expects a +1 style
bounding box..[150:

Thu Mar  7 10:21:19 2019 OK, niftyfingers on reddit suggests the
mnemonic 'cardinality = diameter + 1' which is memorable because
'cardinality' has five syllables while 'diameter' has four, and
'5=4+1' is the same pattern as the mnemonic.  So that would say, yes,
the width and height estimates would not add one, because they are
diameter-like measurements, while the volume estimate would add the
ones, because it's cardinality(-squared).  And we keep cardinality vs
diameter in mind whenever we use the numbers..

:150]

:149]

:148]
:147]

:146]

  :145]
[151:

Thu Mar  7 10:26:46 2019 OK, so, back to QHeading.getShapeOffset

:151][152:

Thu Mar  7 13:32:27 2019 Well had some issues trying to return arrays
of C2Ds, so worked around that at least for now.

:152]
[159:

Thu Mar  7 14:03:57 2019 OK, how is SoftCyt going to use this new information?

:159][160:

Fri Mar  8 15:08:03 2019 OK, so I took a rather extended break to
(pick up cheese head screws at Grainger and get information about a
presentation in May and) develop QWorm.ulam and SWorm.splat.

:160]
[161:

Fri Mar  8 16:39:34 2019 So just picked up a somewhat subtle bug that
I only noticed because I was screwing around flooding the whole
universe with SW, and it seemed the resulting sworms were
preferentially heading west.

Took screenshots in whole_screen_by_date/20190308

Diagnosis was: The sworms weren't preferentially traveling west, but
when a SW head with no tail suicided, if there happened to be another
(even unrelated QW) to its west, the QWorm blowup code 
mistakenly propagated the blowup to it -- because the SW-with-no-tail
had its mDownstream initted to 0 == west.

Fix is to blowup 'manually', in the SW code, if our length is still 0.
Which is kind of gross, but the fundamental blame is that a head
without a tail is just inconsistent at QW level, so it's SW's job to
do _something_ about it, since SW created the head-without-tail
situation to begin with.

:161]
[162:

Fri Mar  8 16:53:58 2019 Committing this stuff.

:162]
[163:

Fri Mar  8 21:40:31 2019 I think to get the cell target shape into
some plausible shape, we're going to need some specific

TODO

 - Review the status of the code regarding size, shape, and melting
   = QHeading.ulam
[164: Fri Mar  8 22:40:53 2019 start with the easy one
DONE :164]   = QVision.ulam
[171: Sat Mar  9 15:04:09 2019 took forever but
DONE :171]   = HardCyt
   = SoftCyt
   = QCyt
   = (QMembrane?)

[172: Sat Mar  9 15:04:27 2019 
DONE :172] - Set up a test situation and save it

[173: Sat Mar  9 15:04:45 2019
DONE :173] - Add debug prints to show the mDistances, the mHeading, and the
   derived shape and offset.

 - Use the saved test situation plus magic wand events to explore how
   reasonable the results look.

:163]
[165:

Sat Mar  9 00:11:02 2019 OK we have yet another foggen
y-axis-direction issue.  When we are representing our estimated
position inside the estimated cell bbox, is the origin in the
southwest with +y going up, or the northwest with +y going down?  We
can sort of do either locally but we need to pick a lane and stick to
it because right now HardCyt.getPositionEstimate is returning (0,-4)
for a lower-left HC, and that helps nobody.

Now, whatever decision we make has to interact with the heading biases
in QHeading.   Like, if QHeading is going south, does the shape get
offset by the +y or by -y?  Perhaps that answer could tell us what to
do here.[166:

Sat Mar  9 00:27:19 2019 I see:

QHeading.ulam:42:    else if (mDir == cDIR2_NORTH) offset.set(h,-s);
QHeading.ulam:43:    else if (mDir == cDIR2_SOUTH) offset.set(h,s);

where h and s are non-negative.

Now, getTargetCell is handed the estimated bbox, but it currently
never uses it, which shakes our willingness to go too far following
that code.  What is it, again, that we want getTargetCell to do?[167:

Sat Mar  9 00:35:16 2019 Well, I thought we wanted it to

(1) Figure out the overall desired shape of the cell, based on
    'platonic esthetics' and the heading

(2) Figure out how to offset that shape relative to the bbox, so that
    in the heading dimension it lands 's' steps beyond that bbox wall,
    while in the orthogonal dimension it divides the bbox extent as
    evenly as possible.

So I do think step (2) requires us to look at the bbox, at least for
certain heading directions.  If the bbox origin is SW with +X right
and +Y up, then when we're heading E or N the offset depends on the
bbox width or height, respectively.  And the even division depends on
the bbox size as well.  So, QHeading.getTargetCell is pretty well and
truly fogged, that's what we would say.[168:

Sat Mar  9 04:25:15 2019 Now I'd thought I worked through this when I
wrote getTargetCell, and had concluded that the bbox dimensions
canceled out when one was computing an offset.. but that's not seeming
right at this point.  Because different headings mean, in effect, that
you have to 'offset the offset' relative to different sides of the
bbox, but the final net offset is relative to the SW corner origin.

:168]

:167]

:166]

:165]
[169:

Sat Mar  9 12:17:00 2019 Well, so've reworked getTargetCell assuming
+y is north, so let's go with that in HardCyt.getPositionEstimate and
then see where the chips fall.

(There's currently only two uses of getPositionEstimate in *.splat,
both in HardCyt: (1) The one we're currently concerned with, (2) one
that immediately takes C2D.length() of the result, so the +y direction
doesn't matter.  (Because, as Dave Wishnia answered the math teacher
on that high school day almost half a century ago: 'Subtraction
commutes inside absolute values.'))

 :169]
[170:

Sat Mar  9 14:36:42 2019 OK, well HC melting due to out-of-target
shape conditions is looking more plausible.  Need to turn to SoftCyt
now.  But trying to start another case print first..  Last time got a
lovely new abort ERR:PRINT FAN ERROR.

:170]
[174:

Sat Mar  9 15:05:03 2019 OK SoftCyt review.  Let's start with what we
currently think we want.  If, considering all its current estimates, a
HC is outside its target shape, it takes a shot to melt.  We'd like
the odds of melting to grow rapidly with the distance outside the
target shape, but we're not doing that yet.  Anyway.

So then we have an SC, initted to state cINBOUND.  Is that what we
want?  Since we're now broadcasting the corporate vision, do we still
need to make the pilgrimmage?

An alternative is just to check any nearby HC for the heading, then
try to do that.  Suppose as a test we init to cOUTBOUND and try to set
up that behavior?

:174]
[175:

Sun Mar 10 10:52:47 2019 Well we're still not moving very well --
although it does appear we're moving somewhat, and under leader
control -- but we have to rotate towards bulk text generation today. 

:175]
[176:

Sun Mar 10 14:52:27 2019 OK.

Intro
Alife for sustainable society
Argument in a nutshell
 0. There's many ways to compute but we fixated on hardware determinism
 1. The resulting machines have been revolutionary
 2. Their consequences are not all good, but we're not about to give them up
 3. Securability is a terrible and increasing problem
 4. Computer architecture matters
 5. Indefinite scalability
 6. Living computation
 7. Soft artificial life as the essential architectural of Computing
    2.0. [178:Sun Mar 10 16:16:47 2019

Then: DReg and Res

 0. It's easy to say move beyond global hardware determinism but it's
    not so easy to do.  'Creeping determinism'.
 1. Even though all software is in principle 'soft', some engineering
    decisions are 'harder' than others 

:178]
[177:

Sun Mar 10 14:58:49 2019 Meeting time.

:177]
:176]
[179:

Sun Mar 10 16:56:20 2019 OK results from the fresh part:

 - Time to create QC flag base class and everbody inherit from it.

 - Including QWorm

 - [Make QWorm TEMP processing be virtual so other classes could do
   custom processing as they move down the worm.]

[180:

Sun Mar 10 17:01:06 2019 But let's commit first.

:180]

:179]
